# TinyaML
# Copyright (C) 2007 Damien Leroux
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
# 
# Grammar for the meta-language, written in tinyaP language.

string = "\"" /([^"\\]|[\\]([\\" trnb]))*/ "\"".

float = /[-]?[0-9]+[.][0-9]+\>/.
int = /[-]?[0-9]+\>/.
sym = /\<[_a-zA-Z][_a-zA-Z0-9]*[?]?\>/.

##
## Opcodes
##
#

p_Opcode =( <Opcode_Float>
	| <Opcode_Int>
	| <Opcode_Label>
	| <Opcode_String>
	| <Opcode_EnvSym>
	| <Opcode_NoArg>
	).

Opcode_NoArg ::= <p_Opcode_NoArg>.
Opcode_Int ::= <p_Opcode_Int> <OpcodeArg_Int>.
Opcode_Float ::= <p_Opcode_Float> <OpcodeArg_Float>.
Opcode_String ::= <p_Opcode_String> <OpcodeArg_String>.
Opcode_Label ::= <p_Opcode_Label> <OpcodeArg_Label>.
Opcode_EnvSym ::= <p_Opcode_EnvSym> <OpcodeArg_EnvSym>.

OpcodeArg_NoArg = epsilon.
OpcodeArg_Int = <int>.
OpcodeArg_Float = <float>.
OpcodeArg_String = <string>.
OpcodeArg_Label = ( "@" <sym> | /[+-][0-9]+/ ).
OpcodeArg_EnvSym = "&" <sym>.

##
## Extendable mnemonics library
##
#

p_Opcode_NoArg = (/\<nop\>/).
p_Opcode_Int = (/\<nop\>/).
p_Opcode_Float = (/\<nop\>/).
p_Opcode_String = (/\<nop\>/).
p_Opcode_Label = (/\<nop\>/).
p_Opcode_EnvSym = (/\<nop\>/).


##
## Labels
##
#

DeclLabel ::= <sym> ":".

##
## Assembly language (programs)
##
#

AsmBloc ::= "asm" <asm_contents> "end".
asm_contents = <asm_statement> ( <asm_contents> | epsilon ).
#asm_loop = ( <asm_statement> <asm_loop> | <asm_statement> "end" ).

asm_statement = ( <DeclLabel> <p_Opcode> | <p_Opcode> ).

Program ::= <program_bloc_loop>.

p_Code = ( <AsmBloc> ).

p_ProgramTopLevel = ( <p_Data> | <p_Code> | <LangDef> | <LangPlug> | <LangComp> | <NewWalker> ).

program_bloc_loop = ( <p_ProgramTopLevel> <program_bloc_loop> | <p_ProgramTopLevel> EOF ).


p_Data = ( <DataBloc> ).

DataBloc ::= "data" <data_loop>.

data = ( <DataInt> | <DataFloat> | <DataString> ).
DataInt ::= <int> ( "rep" <int> | epsilon ).
DataFloat ::= <float> ( "rep" <int> | epsilon ).
DataString ::= <string>.
data_loop = ( <data> <data_loop> | "end" ).



##
## Opcode declarations (libraries)
##
#

DeclOpcode = [ "opcode" <sym> ] <declOpcode_opt_arg>.

declOpcode_opt_arg =	( <DeclOpcode_Float>
			| <DeclOpcode_Int>
			| <DeclOpcode_String>
			| <DeclOpcode_Label>
			| <DeclOpcode_EnvSym>
			| <DeclOpcode_NoArg>
			).

DeclOpcode_Float ::= ":" "Float".
DeclOpcode_Int ::= ":" "Int".
DeclOpcode_String ::= ":" "String".
DeclOpcode_Label ::= ":" "Label".
DeclOpcode_EnvSym ::= ":" "EnvSym".
DeclOpcode_NoArg ::= epsilon.

Library ::= "lib" <lib_decl_loop>.
lib_decl_loop = ( <p_libStatement> <lib_decl_loop> | "end" EOF ).
p_libStatement = ( <DeclOpcode> | <LibFile> ).

LibFile ::= "file" <string>.


##
## Grammar declaration
##
#

LangDef ::= "language" <Grammar>.
LangPlug ::= "plug" <sym> "into" <sym>.
LangComp ::= "compile" <sym> <p_Code>.


##
## Defining new walkers
##
#

NewWalker ::= "walker" <sym> <WalkerBodies>.
WalkerBodies ::= <wabod_loop> "}".
wabod_loop = ( <wabod_loop> <wb_select> | "{" ).	# tinyap feature : weak handling of left recursive rules.
wb_select = ( <WalkerDefault> | <WalkerInit> | <WalkerTerminate> | <WalkerBody> ).
WalkerDefault ::= "default" <p_Code>.
WalkerInit ::= "init" <p_Code>.
WalkerTerminate ::= "terminate" <p_Code>.
WalkerBody ::= "on" <sym> <p_Code>.




##
## Entry point
##
#


_start = (<Program> | <Library> | <Preproc>).

Preproc ::= <req_loop>.

Require ::= "require" <string>.
req_loop = <Require> ( <req_loop> | <Postponed> ).
Postponed ::= /.*/ EOF.





##
## META-GRAMMAR
##
#

elem = /[_a-zA-Z][0-9a-zA-Z_]*/ .
#T ::= ( "\"" "\" /["]/ "\""  | "\"" /[^"]+/ "\""  ) .
T ::= "\"" /([^"\\]|[\\]([\\" trnb]))*/ "\"".
NT ::= "<" <elem> ">"  .
RE ::= "/" /((\[[^\\]]*(\])?[^\]]*])|[^/])*/ "/"  .
rule = ( <OperatorRule> | <TransientRule> ) .
OperatorRule ::= <elem> "::=" <rule_expr> "."  .
TransientRule ::= <elem> "=" <rule_expr> "."  .
rule_expr = ( <Alt> | <Seq> | <rule_elem> ) .
Prefix ::= "[" <rule_expr> "]" <rule_elem>  .
Postfix ::= "{" <rule_expr> "}" <rule_elem>  .
Seq ::= <rule_elem> <seq_expr>  .
Alt ::= "(" <alt_expr> ")"  .
seq_expr = ( <rule_elem> <seq_expr>  | <rule_elem> ) .
alt_expr = ( <rule_elem> "|" <alt_expr>  | <Seq> "|" <alt_expr>  | <Seq> | <rule_elem> ) .
rule_elem = ( <T> | <NT> | <RE> | <Alt> | <EOF> | <epsilon> | <Prefix> | <Postfix> ) .
_start = <Grammar> .
Grammar ::= <gram_loop> .
gram_loop = ( "end" | <rule> <gram_loop>  ) .
EOF ::= "EOF" .
epsilon ::= "epsilon" .

