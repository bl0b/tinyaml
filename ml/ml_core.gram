# TODO: Licence, author
# 
# Grammar for the meta-language

string = ( "\"" "\" /["]/ "\""  | "\"" /[^"]*/ "\""  ). #"\"" /([^\\"]|\\"|\\\\)*/ "\"".
float = /[-]?[0-9]+[.][0-9]+\>/.
int = /[-]?[0-9]+\>/.
sym = /\<[_a-zA-Z][_a-zA-Z0-9]*[?]?\>/.

##
## Opcodes
##
#

p_Opcode =( <Opcode_Float>
	| <Opcode_Int>
	| <Opcode_Label>
	| <Opcode_String>
	| <Opcode_EnvSym>
	| <Opcode_NoArg>
	).

Opcode_NoArg ::= <p_Opcode_NoArg>.
Opcode_Int ::= <p_Opcode_Int> <OpcodeArg_Int>.
Opcode_Float ::= <p_Opcode_Float> <OpcodeArg_Float>.
Opcode_String ::= <p_Opcode_String> <OpcodeArg_String>.
Opcode_Label ::= <p_Opcode_Label> <OpcodeArg_Label>.
Opcode_EnvSym ::= <p_Opcode_EnvSym> <OpcodeArg_EnvSym>.

OpcodeArg_NoArg = epsilon.
OpcodeArg_Int = <int>.
OpcodeArg_Float = <float>.
OpcodeArg_String = <string>.
OpcodeArg_Label = ( "@" <sym> | /[+-][0-9]+/ ).
OpcodeArg_EnvSym = "&" <sym>.

##
## Extendable mnemonics library
##
#

p_Opcode_NoArg = (/\<nop\>/).
p_Opcode_Int = (/\<nop\>/).
p_Opcode_Float = (/\<nop\>/).
p_Opcode_String = (/\<nop\>/).
p_Opcode_Label = (/\<nop\>/).
p_Opcode_EnvSym = (/\<nop\>/).


##
## Labels
##
#

DeclLabel ::= <sym> ":".

##
## Assembly language (programs)
##
#

AsmBloc ::= "asm" <asm_loop>.
asm_loop = ( <asm_statement> <asm_loop> | <asm_statement> "end" ).

asm_statement = ( <DeclLabel> <p_Opcode> | <p_Opcode> ).

Program ::= <program_bloc_loop>.

p_Code = ( <AsmBloc> ).

p_ProgramTopLevel = ( <p_Data> | <p_Code> | <LangDef> | <LangPlug> | <LangComp> ).

program_bloc_loop = ( <p_ProgramTopLevel> <program_bloc_loop> | <p_ProgramTopLevel> EOF ).


p_Data = ( <DataBloc> ).

DataBloc ::= "data" <data_loop>.

data = ( <DataInt> | <DataFloat> | <DataString> ).
DataInt ::= <int> ( "rep" <int> | epsilon ).
DataFloat ::= <float> ( "rep" <int> | epsilon ).
DataString ::= <string>.
data_loop = ( <data> <data_loop> | "end" ).



##
## Opcode declarations (libraries)
##
#

DeclOpcode = [ "opcode" <sym> ] <declOpcode_opt_arg>.

declOpcode_opt_arg =	( <DeclOpcode_Float>
			| <DeclOpcode_Int>
			| <DeclOpcode_String>
			| <DeclOpcode_Label>
			| <DeclOpcode_EnvSym>
			| <DeclOpcode_NoArg>
			).

DeclOpcode_Float ::= ":" "Float".
DeclOpcode_Int ::= ":" "Int".
DeclOpcode_String ::= ":" "String".
DeclOpcode_Label ::= ":" "Label".
DeclOpcode_EnvSym ::= ":" "EnvSym".
DeclOpcode_NoArg ::= epsilon.

Library ::= "lib" <lib_decl_loop>.
lib_decl_loop = ( <p_libStatement> <lib_decl_loop> | "end" EOF ).
p_libStatement = ( <DeclOpcode> | <LibFile> ).

LibFile ::= "file" <string>.


##
## Grammar declaration
##
#

LangDef ::= "language" <Grammar>.
LangPlug ::= "plug" <sym> "into" <sym>.
LangComp ::= "compile" <sym> <p_Code>.



##
## Entry point
##
#


_start = (<Program> | <Library> | <Preproc>).

Preproc ::= <req_loop>.

Require ::= "require" <string>.
req_loop = <Require> ( <req_loop> | <Postponed> ).
Postponed ::= /.*/ EOF.





##
## META-GRAMMAR
##
#

elem = /[_a-zA-Z][0-9a-zA-Z_]*/ .
T ::= ( "\"" "\" /["]/ "\""  | "\"" /[^"]+/ "\""  ) .
NT ::= "<" <elem> ">"  .
RE ::= "/" /((\[[^\\]]*(\])?[^\]]*])|[^/])*/ "/"  .
rule = ( <OperatorRule> | <TransientRule> ) .
OperatorRule ::= <elem> "::=" <rule_expr> "."  .
TransientRule ::= <elem> "=" <rule_expr> "."  .
rule_expr = ( <Alt> | <Seq> | <rule_elem> ) .
Prefix ::= "[" <rule_expr> "]" <rule_elem>  .
Postfix ::= "{" <rule_expr> "}" <rule_elem>  .
Seq ::= <rule_elem> <seq_expr>  .
Alt ::= "(" <alt_expr> ")"  .
seq_expr = ( <rule_elem> <seq_expr>  | <rule_elem> ) .
alt_expr = ( <rule_elem> "|" <alt_expr>  | <Seq> "|" <alt_expr>  | <Seq> | <rule_elem> ) .
rule_elem = ( <T> | <NT> | <RE> | <Alt> | <EOF> | <epsilon> | <Prefix> | <Postfix> ) .
_start = <Grammar> .
Grammar ::= <gram_loop> .
gram_loop = ( "end" | <rule> <gram_loop>  ) .
EOF ::= "EOF" .
epsilon ::= "epsilon" .

