        lib

      # stack management
        opcode push:Int
        opcode push:Float
        opcode push:String
        opcode push:Opcode
        opcode pop
        opcode pop:Int          # pop n values
        opcode dup:Int          # duplicate n-th value on top of stack
      # tests
        opcode SZ               # skip next instruction if zero
        opcode SNZ              # skip next instruction if non zero
      # jumps
        opcode jmp:Label        # relative intra-segment jump
      # call stack
        opcode call:Label       # intra-segment call
        opcode lcall:Label      # pop segment then perform long call
        opcode retval:Int       # copy stack top then pop out n values
                                # then poke old stack top then return
        opcode ret:Int          # pop out n values then return
      # address space management
        opcode enter:Int        # reserve n local variables
        opcode leave:Int        # undo previous enter
        opcode getmem:Int       # n>0  : push n-th global data
                                # n<=0 : push n-th local data
        opcode setmem:Int       # pop data into mem cell #n (see above)
        opcode getmem           # pop n from data stack then getmem n
        opcode setmem           # pop n from data stack then setmem n
      # bin&arith
        opcode shr              # shift right
        opcode shr:Int          # shift right n bits
        opcode vshr             # pop n then shift right n bits

        opcode shl              # shift left
        opcode shl:Int          # shift left n bits
        opcode vshl             # pop n then shift left n bits

        opcode and
        opcode or
        opcode not
        opcode xor
        opcode and:Int
        opcode or:Int
        opcode xor:Int

        opcode inc
        opcode dec

        opcode mod
        opcode mod:Int
        opcode mod:Float

        opcode add              # use two values on top of stack
        opcode sub
        opcode mul
        opcode div

        opcode add:Int          # use top of stack and immed value
        opcode sub:Int
        opcode mul:Int
        opcode div:Int

        opcode add:Float
        opcode sub:Float
        opcode mul:Float
        opcode div:Float
      # AST manipulation
        opcode astGetOp
        opcode astGetChildString
        opcode astGetChildString:Int
        opcode astGetChildrenCount
        opcode astCompileChild:Int
        opcode astCompileChild

      # compiler manipulation
        opcode __addCompileMethod:Label
        opcode write_data               # pop data, pop rep, write
        opcode write_label:String
        opcode write_oc:String
        opcode write_oc_Int:String
        opcode write_oc_Float:String
        opcode write_oc_Label:String
        opcode write_oc_String:String

        opcode compileStateNext
        opcode compileStateDown
        opcode compileStateUp
        opcode compileStateError

        opcode pp_curNode

        opcode _pop_curNode

      # handling symbol tables
        opcode newSymTab                # create a new sym tab and push
                                        # it onto data stack
        opcode symTabSz
        opcode getSym                   # pop key, pop table, push result
        opcode addSym                   # pop key, pop table

      # string operations
        opcode strcmp                   # compare two strings

      # basic conversions
        opcode toS
        opcode toI
        opcode toF

      # FIXME: output and debug mechanisms
        opcode print:Int
        end

