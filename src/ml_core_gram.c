/* TinyaML
 * Copyright (C) 2007 Damien Leroux
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

const char* ml_core_grammar = "((Grammar (Comment #\\ TinyaML) (Comment #\\ Copyright\\ \\(C\\)\\ 2007\\ Damien\\ Leroux) (Comment #\\ ) (Comment #\\ This\\ program\\ is\\ free\\ software;\\ you\\ can\\ redistribute\\ it\\ and/or) (Comment #\\ modify\\ it\\ under\\ the\\ terms\\ of\\ the\\ GNU\\ General\\ Public\\ License) (Comment #\\ as\\ published\\ by\\ the\\ Free\\ Software\\ Foundation;\\ either\\ version\\ 2) (Comment #\\ of\\ the\\ License,\\ or\\ \\(at\\ your\\ option\\)\\ any\\ later\\ version.) (Comment #\\ ) (Comment #\\ This\\ program\\ is\\ distributed\\ in\\ the\\ hope\\ that\\ it\\ will\\ be\\ useful,) (Comment #\\ but\\ WITHOUT\\ ANY\\ WARRANTY;\\ without\\ even\\ the\\ implied\\ warranty\\ of) (Comment #\\ MERCHANTABILITY\\ or\\ FITNESS\\ FOR\\ A\\ PARTICULAR\\ PURPOSE.\\ \\ See\\ the) (Comment #\\ GNU\\ General\\ Public\\ License\\ for\\ more\\ details.) (Comment #\\ ) (Comment #\\ You\\ should\\ have\\ received\\ a\\ copy\\ of\\ the\\ GNU\\ General\\ Public\\ License) (Comment #\\ along\\ with\\ this\\ program;\\ if\\ not,\\ write\\ to\\ the\\ Free\\ Software) (Comment #\\ Foundation,\\ Inc.,\\ 59\\ Temple\\ Place\\ -\\ Suite\\ 330,\\ Boston,\\ MA\\ \\ 02111-1307,\\ USA.) (Comment #\\ ) (Comment #\\ Grammar\\ for\\ the\\ meta-language,\\ written\\ in\\ tinyaP\\ 'short'\\ language.) (TransientRule string (STR \" \")) (TransientRule float (RE [-]?[0-9]+[.][0-9]+\\\\b)) (TransientRule int (RE [-]?[0-9]+\\\\b)) (TransientRule sym (RE \\\\b[_a-zA-Z][_a-zA-Z0-9]*\\\\b)) (TransientRule char (RawSeq (T ') (RE \\\\[\\\\'trn]|.) (T '))) (Comment ##) (Comment ##\\ Opcodes) (Comment ##) (TransientRule asm_statement (Alt (NT DeclLabel) (NT Opcode_Float) (NT Opcode_Int) (NT Opcode_Char) (NT Opcode_Label) (NT Opcode_String) (NT Opcode_EnvSym) (NT Opcode_NoArg))) (TransientRule decl_opcode (AddToBag (RE [_a-zA-Z][_a-zA-Z0-9]*) opcode !)) (TransientRule opcode_sym (BOW opcode !)) (OperatorRule Opcode_NoArg (NT opcode_sym)) (OperatorRule Opcode_Int (Seq (NT opcode_sym) (NT OpcodeArg_Int))) (OperatorRule Opcode_Char (Seq (NT opcode_sym) (NT OpcodeArg_Char))) (OperatorRule Opcode_Float (Seq (NT opcode_sym) (NT OpcodeArg_Float))) (OperatorRule Opcode_String (Seq (NT opcode_sym) (NT OpcodeArg_String))) (OperatorRule Opcode_Label (Seq (NT opcode_sym) (NT OpcodeArg_Label))) (OperatorRule Opcode_EnvSym (Seq (NT opcode_sym) (NT OpcodeArg_EnvSym))) (TransientRule OpcodeArg_NoArg (Epsilon)) (TransientRule OpcodeArg_Int (NT int)) (TransientRule OpcodeArg_Char (NT char)) (TransientRule OpcodeArg_Float (NT float)) (TransientRule OpcodeArg_String (NT string)) (TransientRule OpcodeArg_Label (Alt (Seq (T @) (NT sym)) (RE [+-][0-9]+))) (TransientRule OpcodeArg_EnvSym (Seq (T &) (NT sym))) (Comment ##) (Comment ##\\ Labels) (Comment ##) (OperatorRule DeclLabel (Seq (NT sym) (T :))) (Comment ##) (Comment ##\\ Assembly\\ language\\ \\(programs\\)) (Comment ##) (OperatorRule AsmBloc (Seq (T asm) (NT asm_statements) (T end))) (TransientRule asm_statements (Alt (NT asm_statement) (Seq (NT asm_statements) (NT asm_statement)))) (OperatorRule Program (Seq (Rep1N (NT p_ProgramTopLevel)) (EOF))) (TransientRule p_Code (NT AsmBloc)) (TransientRule p_ProgramTopLevel (Alt (NT p_Data) (NT p_Code) (NT LangDef) (NT LangComp) (NT NewWalker))) (TransientRule p_Data (NT DataBloc)) (OperatorRule DataBloc (Seq (T data) (Rep1N (NT data)) (T end))) (TransientRule data (Alt (NT DataFloat) (NT DataInt) (NT DataChar) (NT DataString))) (OperatorRule DataInt (Seq (NT int) (Rep01 (Seq (T rep) (NT int))))) (OperatorRule DataFloat (Seq (NT float) (Rep01 (Seq (T rep) (NT int))))) (OperatorRule DataString (NT string)) (OperatorRule DataChar (NT char)) (Comment ##) (Comment ##\\ Opcode\\ declarations\\ \\(libraries\\)) (Comment ##) (TransientRule DeclOpcode (Seq (T opcode) (NT DeclOpcodeOverloads))) (TransientRule declOpcode_opt_arg (Alt (NT DeclOpcode_Float) (NT DeclOpcode_Int) (NT DeclOpcode_Char) (NT DeclOpcode_String) (NT DeclOpcode_Label) (NT DeclOpcode_EnvSym) (NT DeclOpcode_NoArg))) (OperatorRule DeclOpcode_Float (Seq (NT decl_opcode) (T :) (T Float))) (OperatorRule DeclOpcode_Int (Seq (NT decl_opcode) (T :) (T Int))) (OperatorRule DeclOpcode_Char (Seq (NT decl_opcode) (T :) (T Char))) (OperatorRule DeclOpcode_String (Seq (NT decl_opcode) (T :) (T String))) (OperatorRule DeclOpcode_Label (Seq (NT decl_opcode) (T :) (T Label))) (OperatorRule DeclOpcode_EnvSym (Seq (NT decl_opcode) (T :) (T EnvSym))) (OperatorRule DeclOpcode_NoArg (NT decl_opcode)) (OperatorRule DeclOpcodeOverloads (NT declOpcode_opt_arg)) (OperatorRule DeclOpcodeOverloads (Seq (NT declOpcode_opt_arg) (T \\() (NT DeclOpcode_Overload) (Rep0N (Seq (T ,) (NT DeclOpcode_Overload))) (T \\)))) (OperatorRule DeclOpcode_Overload (Seq (NT int) (Rep01 (Seq (T =) (NT declOpcode_opt_arg))))) (OperatorRule Library (Seq (T lib) (Rep1N (NT p_libStatement)) (T end) (Alt (EOF) (NT Postponed)))) (TransientRule p_libStatement (Alt (NT DeclOpcode) (NT LibFile))) (OperatorRule LibFile (Seq (T file) (NT string))) (Comment ##) (Comment ##\\ Grammar\\ declaration) (Comment ##) (OperatorRule LangDef (Seq (T language) (NT Grammar) (T end))) (OperatorRule LangComp (Seq (T compile) (NT sym) (NT p_Code))) (Comment ##) (Comment ##\\ Defining\\ new\\ walkers) (Comment ##) (OperatorRule NewWalker (Seq (T walker) (NT sym) (NT WalkerBodies))) (OperatorRule WalkerBodies (Seq (T {) (Rep1N (NT wb_select)) (T }))) (TransientRule wb_select (Alt (NT WalkerDefault) (NT WalkerInit) (NT WalkerTerminate) (NT WalkerBody))) (OperatorRule WalkerDefault (Seq (T default) (NT p_Code))) (OperatorRule WalkerInit (Seq (T init) (NT p_Code))) (OperatorRule WalkerTerminate (Seq (T terminate) (NT p_Code))) (OperatorRule WalkerBody (Seq (T on) (NT sym) (NT p_Code))) (Comment ##) (Comment ##\\ Entry\\ point) (Comment ##) (TransientRule _start (NT toplevel)) (TransientRule toplevel (Alt (NT Program) (NT Library) (NT Preproc))) (OperatorRule Preproc (Seq (Rep1N (NT rqll)) (Alt (EOF) (NT Postponed)))) (OperatorRule Include (Seq (T include) (NT string))) (OperatorRule Require (Seq (T require) (NT string))) (OperatorRule LoadLib (Seq (T loadlib) (NT sym))) (TransientRule rqll (Alt (NT Include) (NT Require) (NT LoadLib))) (OperatorRule Postponed (STR  )) (Comment #Postponed\\ ::=\\ ~,~\\ .eof.) (Comment #Postponed\\ ::=\\ /.+/\\ .eof.) (Comment ##) (Comment ##\\ META-GRAMMAR) (Comment ##) (Comment ##\\ adapted\\ from\\ a\\ copypasta\\ of\\ tinyap's\\ `short'\\ dialect.) (Comment ##) (Comment #\\ TinyaP\\ :\\ this\\ is\\ not\\ yet\\ another\\ ) (Comment #\\ Copyright\\ \\(C\\)\\ 2007-2011\\ Damien\\ Leroux) (Comment #) (Comment #\\ This\\ program\\ is\\ free\\ software;\\ you\\ can\\ redistribute\\ it\\ and/or) (Comment #\\ modify\\ it\\ under\\ the\\ terms\\ of\\ the\\ GNU\\ General\\ Public\\ License) (Comment #\\ as\\ published\\ by\\ the\\ Free\\ Software\\ Foundation;\\ either\\ version\\ 2) (Comment #\\ of\\ the\\ License,\\ or\\ \\(at\\ your\\ option\\)\\ any\\ later\\ version.) (Comment #) (Comment #\\ This\\ program\\ is\\ distributed\\ in\\ the\\ hope\\ that\\ it\\ will\\ be\\ useful,) (Comment #\\ but\\ WITHOUT\\ ANY\\ WARRANTY;\\ without\\ even\\ the\\ implied\\ warranty\\ of) (Comment #\\ MERCHANTABILITY\\ or\\ FITNESS\\ FOR\\ A\\ PARTICULAR\\ PURPOSE.\\ \\ See\\ the) (Comment #\\ GNU\\ General\\ Public\\ License\\ for\\ more\\ details.) (Comment #) (Comment #\\ You\\ should\\ have\\ received\\ a\\ copy\\ of\\ the\\ GNU\\ General\\ Public\\ License) (Comment #\\ along\\ with\\ this\\ program;\\ if\\ not,\\ write\\ to\\ the\\ Free\\ Software) (Comment #\\ Foundation,\\ Inc.,\\ 59\\ Temple\\ Place\\ -\\ Suite\\ 330,\\ Boston,\\ MA\\ \\ 02111-1307,\\ USA.) (Comment #) (Comment #) (Comment #\\ Production\\ Atoms) (Comment #) (TransientRule symbol (RE [_a-zA-Z][0-9a-zA-Z_]*)) (OperatorRule T (STR \" \")) (OperatorRule NT (NT symbol)) (OperatorRule RE (STR / /)) (OperatorRule STR (RawSeq (T ~) (RE [^~,]?) (T ,) (RE [^~,]?) (T ~))) (OperatorRule BOW (RawSeq (T ~) (RE [_a-zA-Z][_a-zA-Z0-9]*) (RE !?) (T ~))) (OperatorRule AddToBag (Seq (NT RE) (T :) (NT symbol) (RE !?))) (Comment #) (Comment #\\ Compositions) (Comment #) (OperatorRule RawSeq (Seq (T .raw) (Rep1N (Seq (Space) (Alt (NT T) (NT STR) (NT RE) (NT BOW) (NT AddToBag)))))) (TransientRule alt_elem (Alt (NT RawSeq) (NT Seq) (NT single))) (OperatorRule Seq (Seq (NT single) (Rep1N (Seq (Space) (NT single))))) (OperatorRule Alt (Seq (NT alt_elem) (Rep1N (Seq (Space) (T |) (Space) (NT alt_elem))))) (OperatorRule Rep01 (Seq (NT single_norep) (T ?))) (OperatorRule Rep1N (Seq (NT single_norep) (T +))) (OperatorRule Rep0N (Seq (NT single_norep) (T *))) (TransientRule single (Alt (NT Rep01) (NT Rep0N) (NT Rep1N) (NT single_norep) (NT Space) (NT NewLine) (NT Indent) (NT Dedent))) (TransientRule single_norep (Alt (NT Prefix) (NT Postfix) (NT NT) (NT STR) (NT BOW) (NT AddToBag) (NT T) (NT RE) (NT Epsilon) (NT EOF) (NT sub_rmb))) (OperatorRule Prefix (Seq (T [) (NT rmember) (T ]) (NT NT))) (OperatorRule Postfix (Seq (T {) (NT rmember) (T }) (NT NT))) (Comment #) (Comment #\\ Top-level) (Comment #) (OperatorRule TransientRule (Seq (NT symbol) (Space) (T =) (Space) (NT rmember) (T .) (NewLine))) (OperatorRule OperatorRule (Seq (NT symbol) (Space) (T ::=) (Space) (NT rmember) (T .) (NewLine))) (TransientRule rmember (Alt (NT Alt) (NT alt_elem))) (TransientRule sub_rmb (Seq (T \\() (Alt (NT Seq) (NT Alt) (NT RawSeq)) (T \\)))) (OperatorRule Comment (Seq (RE #.*) (NewLine))) (OperatorRule Grammar (Rep1N (NT gram_toplevel))) (TransientRule gram_toplevel (Alt (NT TransientRule) (NT OperatorRule))) (Comment #) (Comment #\\ Miscellaneous) (Comment #) (Comment #_start\\ =\\ Grammar.) (TransientRule _whitespace (RE \\(#[^\\n]*\\n|[\\ \\r\\n\\t]\\)+)) (OperatorRule EOF (T .eof)) (OperatorRule Epsilon (T .epsilon)) (OperatorRule Space (T .space)) (OperatorRule NewLine (T .newline)) (OperatorRule Indent (T .indent)) (OperatorRule Dedent (T .dedent))))";

const char* ml_core_lib =
"# TinyaML\n"
"# Copyright (C) 2007 Damien Leroux\n"
"# \n"
"# This program is free software; you can redistribute it and/or\n"
"# modify it under the terms of the GNU General Public License\n"
"# as published by the Free Software Foundation; either version 2\n"
"# of the License, or (at your option) any later version.\n"
"# \n"
"# This program is distributed in the hope that it will be useful,\n"
"# but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"# GNU General Public License for more details.\n"
"# \n"
"# You should have received a copy of the GNU General Public License\n"
"# along with this program; if not, write to the Free Software\n"
"# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n"
"\n"
"lib\n"
"        opcode nop\n"
"        opcode nop:EnvSym\n"
"        opcode nop:Int\n"
"        opcode nop:Char\n"
"        opcode nop:Float\n"
"        opcode nop:String\n"
"        opcode nop:Label\n"
"      # stack management\n"
"        opcode push:Int\n"
"        opcode push:Char\n"
"        opcode push:Float\n"
"        opcode push:String\n"
"\n"
"        opcode pop   \n"
"        opcode popN    \n"
"        opcode pop:Int          # pop n values\n"
"        opcode dup:Int          # duplicate n-th value on top of stack\n"
"        opcode swap:Int         # swap top and top-offset on data stack\n"
"\n"
"      # char/int conversions\n"
"        opcode chr:Int          # push char\n"
"        opcode chr      (1)    # pop int, push char\n"
"        opcode ord:Char         # push int\n"
"        opcode ord      (1)    # pop char, push int\n"
"\n"
"      # objects\n"
"        opcode clone (1)\n"
"\n"
"      # tests\n"
"\n"
"        opcode inf (2,1=supEq)\n"
"        opcode sup (2,1=infEq)\n"
"        opcode eq (2,1=nEq)\n"
"        opcode nEq (2,1=eq)\n"
"        opcode infEq (2,1=sup)\n"
"        opcode supEq (2,1=inf)\n"
"\n"
"        opcode SZ               # skip next instruction if zero\n"
"        opcode SNZ              # skip next instruction if non zero\n"
"      # raw exception handling\n"
"        opcode instCatcher:Label        # try {         # label is catch address\n"
"        opcode uninstCatcher:Label      # }             # label is end\n"
"                                                        # of catch bloc\n"
"        opcode throw                    # try and pop data and jump to\n"
"                                        # top catcher or fail\n"
"        opcode getException             # push current exception\n"
"        \n"
"      # jumps\n"
"        opcode jmp:Label        # relative intra-segment jump\n"
"      # call stack\n"
"        opcode call (1)        # call a function object\n"
"        opcode call_vc          # pop function object, pop array or\n"
"                                # VObj, use the latter as closure and\n"
"                                # call the former.\n"
"        opcode call:Label       # intra-segment call (no closure support)\n"
"        opcode retval:Int       # copy stack top then pop out n values\n"
"                                # then poke old stack top then return\n"
"        opcode ret:Int          # pop out n values then return\n"
"\n"
"      # function objects\n"
"        opcode dynFunNew:Label   # push func obj\n"
"        opcode dynFunAddClosure (2)  # pop (data to clone)\n"
"        opcode getClosure:Int    # pop (data to clone)\n"
"        opcode getClosure        # pop index, pop (data to clone)\n"
"        opcode setClosure:Int    # pop (data to set)\n"
"        opcode setClosure        # pop index, pop (data to set)\n"
"\n"
"      # address space management\n"
"        opcode enter:Int        # reserve n local variables\n"
"        opcode leave:Int        # undo previous enter\n"
"\n"
"        opcode getClosure:Int\n"
"\n"
"        opcode getmem:Int       # n>0  : push n-th global data\n"
"                                # n<=0 : push n-th local data\n"
"        opcode setmem:Int       # pop data into mem cell #n (see above)\n"
"        opcode getmem           # pop n from data stack then getmem n\n"
"        opcode setmem           # pop n from data stack then setmem n\n"
"      # bin&arith\n"
"        opcode shr (1)             # shift right\n"
"        opcode shr:Int (1)         # shift right n bits\n"
"        opcode vshr (2)            # pop n then shift right n bits\n"
"\n"
"        opcode shl (1)             # shift left\n"
"        opcode shl:Int (1)         # shift left n bits\n"
"        opcode vshl (2)            # pop n then shift left n bits\n"
"\n"
"        opcode and (1,2)\n"
"        opcode or (1,2)\n"
"        opcode not (1)\n"
"        opcode neg (1)\n"
"        opcode xor (1,2)\n"
"        opcode and:Int (1)\n"
"        opcode or:Int (1)\n"
"        opcode xor:Int (1)\n"
"\n"
"        opcode inc (1)\n"
"        opcode dec (1)\n"
"\n"
"        opcode rmod (2,1=mod)\n"
"        opcode mod (2,1=rmod)\n"
"        opcode mod:Int (1)\n"
"        opcode mod:Float\n"
"\n"
"        opcode add (1,2)             # use two values on top of stack\n"
"        opcode sub (2,1=rsub)\n"
"        opcode rsub (2,1=sub)\n"
"        opcode mul (1,2)\n"
"        opcode div (2,1=rdiv)\n"
"        opcode rdiv (2,1=div)\n"
"\n"
"        opcode add:Int (1)         # use top of stack and immed value\n"
"        opcode sub:Int (1)\n"
"        opcode mul:Int (1)\n"
"        opcode div:Int (1)\n"
"\n"
"        opcode add:Float (1)\n"
"        opcode sub:Float (1)\n"
"        opcode mul:Float (1)\n"
"        opcode div:Float (1)\n"
"\n"
"        opcode sin (1)\n"
"        opcode cos (1)\n"
"        opcode tan (1)\n"
"\n"
"        opcode sqrt (1)         # pop float, push sqrt(value)\n"
"        opcode log  (1)         # pop float, push ln(value)\n"
"        opcode log:Float (1)    # pop float, push ln(value)/ln(arg)\n"
"        opcode exp (1)          # pop float, push exp(float)\n"
"        opcode pow (1)          # pop int/float (x), pop int/float (y),\n"
"                                # push float (x^y)\n"
"\n"
"      # AST manipulation\n"
"        opcode astGetOp\n"
"        opcode astGetRow\n"
"        opcode astGetCol\n"
"        opcode astGetChildString\n"
"        opcode astGetChildString:Int\n"
"        opcode astGetChildrenCount\n"
"        opcode astCompileChild:Int\n"
"        opcode astCompileChild\n"
"\n"
"      # compiler manipulation\n"
"        opcode onCompInit               # pop dynFun\n"
"        opcode onCompTerm               # pop dynFun\n"
"        opcode __addCompileMethod:Label\n"
"        opcode write_data               # pop data, pop rep, write\n"
"        opcode write_label:String\n"
"        opcode write_label\n"
"        opcode write_oc:String\n"
"        opcode write_ocInt:String\n"
"        opcode write_ocChar:String\n"
"        opcode write_ocFloat:String\n"
"        opcode write_ocLabel:String\n"
"        opcode write_ocString:String\n"
"        opcode write_ocEnvSym:String\n"
"        opcode write_oc\n"
"        opcode write_ocInt\n"
"        opcode write_ocChar\n"
"        opcode write_ocFloat\n"
"        opcode write_ocLabel\n"
"        opcode write_ocString\n"
"        opcode write_ocEnvSym\n"
"\n"
"        opcode compileStateNext\n"
"        opcode compileStateDown\n"
"        opcode compileStateUp\n"
"        opcode compileStateDone\n"
"        opcode compileStateError\n"
"\n"
"        opcode pp_curNode\n"
"\n"
"        #opcode _pop_curNode\n"
"\n"
"        opcode _langDef:String\n"
"        opcode _langPlug:String         # pop plug\n"
"\n"
"        opcode compileString		# compile in the current compiler context\n"
"        opcode compileStringToThread:Int # pop buffer, push thread\n"
"                                         # with given prio\n"
"        opcode compileStringToThread	# pop int(prio), pop buffer,\n"
"                                        # push thread\n"
"        opcode compileFileToThread:Int	# pop filename, push thread\n"
"                                        # with given prio\n"
"        opcode compileFileToThread	# pop int(prio), pop filename,\n"
"                                        # push thread\n"
"\n"
"        opcode doWalk:String            # walk current node with named\n"
"        opcode doWalk                   # walker, or pop name from stack\n"
"        opcode walkChild:Int            # perform walking on this child\n"
"        opcode walkChild\n"
"\n"
"      # handling symbol tables\n"
"        opcode newSymTab                # create a new sym tab and push\n"
"                                        # it onto data stack\n"
"        opcode symTabSz (1)\n"
"        opcode getSym   (2)             #pop key, pop table, push index\n"
"        opcode getSymName (2)           #pop key, pop table, push symbol\n"
"        opcode addSym (2)               # pop key, pop table\n"
"\n"
"      # runtime environment\n"
"        opcode envLookup                # [symbol] => offset\n"
"        opcode envGet                   # [symbol] => env value\n"
"        opcode envGet:EnvSym\n"
"        opcode envSet:EnvSym\n"
"        opcode envAdd\n"
"\n"
"        opcode mapNew\n"
"        opcode mapHasKey (1)\n"
"        opcode mapGet (2)\n"
"        opcode mapSet (3)\n"
"        opcode mapHasKey:String (1)\n"
"        opcode mapGet:String (1)\n"
"        opcode mapSet:String (1)\n"
"        opcode mapKeys (1)\n"
"\n"
"      # handling arrays\n"
"        opcode arrayNew\n"
"        opcode arrayResv:Int (1)\n"
"        opcode arrayResv (2)\n"
"        opcode arrayGet:Int (1)\n"
"        opcode arrayGet (2)\n"
"        opcode arraySet:Int (1)\n"
"        opcode arraySet (2)\n"
"        opcode arraySize (1)\n"
"\n"
"      # handling object stacks\n"
"        opcode stackNew\n"
"        opcode stackPush (2)\n"
"        opcode stackPop (1)\n"
"        opcode stackPeek (2)\n"
"        opcode stackPop:Int (1)\n"
"        opcode stackPeek:Int (1)\n"
"        opcode stackSize (1)\n"
"\n"
"      # string operations\n"
"        opcode strcmp:String (1)\n"
"        opcode strcat:String (1)\n"
"        opcode strdup:String (1)\n"
"        opcode strcmp (1,2)\n"
"        opcode strcat (2)\n"
"        opcode strdup (1)\n"
"        opcode strlen (1)\n"
"        opcode charAt:Int (1)\n"
"        opcode setCharAt:Int (1)\n"
"        opcode charAt (2)\n"
"        opcode setCharAt (2)\n"
"        opcode substr (3)\n"
"\n"
"      # basic conversions\n"
"        opcode toS (1)\n"
"        opcode toI (1)\n"
"        opcode toF (1)\n"
"\n"
"      # threading\n"
"        opcode newThread:Label          # pop prio\n"
"        opcode newThread                # pop prio\n"
"        opcode getPid                   # push int\n"
"        opcode yield                    # yield current thread\n"
"        opcode joinThread               # pop int thread pid\n"
"        opcode killThread               # pop int thread pid\n"
"\n"
"        opcode newMtx\n"
"        opcode lockMtx:Int              # ref a memcell\n"
"        opcode unlockMtx:Int            # same\n"
"        opcode lockMtx                  # pop int memcell\n"
"        opcode unlockMtx                # same\n"
"\n"
"      # Critical sections\n"
"        opcode crit_begin\n"
"        opcode crit_end\n"
"\n"
"      # time-slice management\n"
"        opcode _set_timeslice:Int\n"
"        opcode _set_timeslice\n"
"        opcode _get_timeslice\n"
"\n"
"      # accessing thread registers\n"
"        opcode regGet:Int               # push reg value\n"
"        opcode regGet                   # pop index, push reg value\n"
"        opcode regSet:Int               # pop value\n"
"        opcode regSet                   # pop index, pop value\n"
"\n"
"      # FIXME: output and debug mechanisms\n"
"        opcode print:Int\n"
"        opcode print                    # pop number of items, pop each item\n"
"\n"
"      # Access to internals\n"
"        opcode _vm_prog_get_globals     # push symtab\n"
"        opcode typeof			# pop any, push int (Data* constant)\n"
"\n"
"      # Virtual objects (raw access)\n"
"        opcode _vobj_new      (1)\n"
"        opcode _vobj_init     (1)\n"
"        opcode _vobj_gofs     (1)\n"
"        opcode _vobj_sofs     (2)\n"
"        opcode _vobj_gcls     (1)\n"
"        opcode _vobj_scls     (2)\n"
"        opcode _vobj_cmbr     (1)\n"
"        opcode _vobj_gmbr:Int (1)\n"
"        opcode _vobj_gmbr     (2)\n"
"        opcode _vobj_smbr:Int (2)\n"
"        opcode _vobj_smbr     (3)\n"
"        opcode _vcls_new      (1)\n"
"        opcode _vcls_gname    (1)\n"
"        opcode _vcls_sname    (2)\n"
"        opcode _vcls_gbase    (1)\n"
"        opcode _vcls_sbase    (2)\n"
"        opcode _vcls_cto      (2)\n"
"        opcode _vcls_cfrom    (1)\n"
"        opcode _vcls_soo      (4) # cls, str (opcode), int (argtype), dyn_fun\n"
"\n"
"        opcode cast (2=_vcls_cfrom,1=_vcls_cto)\n"
"\n"
"       end\n"
;
