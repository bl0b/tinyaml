require "tests/struc.melang"

glob
	glob_dic = 0
	func_dic = 0
	func_tab = 0
	local_dic_stack = 0
# for scope management :
	symIsLocal = 101
	symIsParam = 102
	symIsGlobal = 103
	symIsClosure = 104
	symMustEnclose = 105
	symUnknown = 106

	cur_fname = 0
	lbl_counter = 0

	call_local_ofs = 0
end

struc FuncDecl {
	returns		# int : maximum count of returned values
	parameters	# symtab : parameters
	locals		# symtab : local variables
	closure		# symtab : enclosed variables
	label		# string : start label
}


walker analyzeFuncDecl {

	init asm
		nop
	end

	terminate asm
		nop
	end

	default asm
		push "analyzeFuncDecl default on " astGetOp push "\\n" print 3
		compileStateNext
	end

	on script_fun asm
		# process param list
		walkChild 1

		+$cur_fname
		call @funcDeclEnter

		# process body
		walkChild 2

		call @funcDeclLeave

		compileStateDone
	end



	on script_param_list asm
		enter 1				# counter
		push 0 setmem -1
	_spl_loop:
		getmem -1 astGetChildrenCount nEq [
			+$cur_fname
			getmem -1
			astGetChildString
			call @funcDeclAddParam
			getmem -1 inc setmem -1
			jmp @_spl_loop
		]
		leave 1
		compileStateDone
	end


	on script_local asm
		enter 1				# counter
		push 0 setmem -1
	_sl_loop:
		getmem -1 astGetChildrenCount nEq [
			+$cur_fname
			getmem -1
			astGetChildString
			call @funcDeclAddLocal
			getmem -1 inc setmem -1
			jmp @_sl_loop
		]
		leave 1
		compileStateNext
	end

	on script_id asm
		enter 1
		+$cur_fname
		astGetChildString 0
		call @getSymContext 
		setmem -1
		getmem -1 $symIsLocal eq [ push "symbol is local\n" print 1]
		getmem -1 $symIsParam eq [ push "symbol is param\n" print 1]
		getmem -1 $symIsGlobal eq [ push "symbol is global\n" print 1]
		getmem -1 $symIsClosure eq [ push "symbol inside closure\n" print 1]
		getmem -1 $symMushEnclose eq [ push "symbol must be enclosed\n" print 1]
		getmem -1 $symUnknown eq [ push "symbol is unknown\n" print 1]
		leave 1
		compileStateNext
	end


	on script_assign asm
		enter 1
		+$cur_fname
		astGetChildString 0
		call @getSymContext 
		setmem -1
		getmem -1 $symIsLocal eq [ push "symbol is local\n" print 1]
		getmem -1 $symIsParam eq [ push "symbol is param\n" print 1]
		getmem -1 $symIsGlobal eq [ push "symbol is global\n" print 1]
		getmem -1 $symIsClosure eq [ push "symbol inside closure\n" print 1]
		getmem -1 $symMushEnclose eq [ push "symbol must be enclosed\n" print 1]
		getmem -1 $symUnknown eq [ push "symbol is unknown\n" print 1]
		walkChild 1
		leave 1
		compileStateNext
	end


	on script_fun_body asm compileStateDown end

	on script_print asm compileStateDown end

	on m_expr asm compileStateDown end
	on b_expr asm compileStateDown end
	on comp asm compileStateDown end
	on m_add asm compileStateDown end
	on m_sub asm compileStateDown end
	on m_mul asm compileStateDown end
	on m_div asm compileStateDown end
	on b_not asm compileStateDown end
	on b_and asm compileStateDown end
	on b_or asm compileStateDown end
	on script_call asm compileStateDown end
	on script_if asm compileStateDown end
	on sub_bloc asm compileStateDown end
}

asm
	newSymTab -$glob_dic
	newSymTab -$func_dic
	arrayNew  -$func_tab
	+$func_tab push 0 push 0 arraySet
	stackNew -$local_dic_stack
	jmp @_skip_0

# string:something -> string:label
gen_label:
	+$lbl_counter inc -$lbl_counter
	push "_" +$lbl_counter toS strcat strcat
	ret 0

newFuncDecl:
	enter 1
	# backup func name
	setmem -1
	# insert symbol into tab
	+$func_dic
	getmem -1
	addSym
	# add new func decl entry into tab
	+$func_tab
	# create structure
	strucNew FuncDecl {
		returns : push 0
		parameters : newSymTab
		locals : newSymTab
		closure : newSymTab
		label : push ""
	}
	# fetch index of sym
	+$func_dic getmem -1 getSym
	arraySet
	pop
	leave 1
	ret 0

funcDeclGet:
	enter 1 setmem -1
	+$func_tab
	+$func_dic getmem -1 getSym
	arrayGet
	leave 1
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddParam:
	enter 1
	# pop param name
	setmem -1
	call @funcDeclGet +(FuncDecl.parameters)
	getmem -1
	addSym
	leave 1
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddLocal:
	enter 1
	# pop param name
	setmem -1
	call @funcDeclGet +(FuncDecl.locals)
	getmem -1
	addSym
	leave 1
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddClosure:
	enter 1
	# pop param name
	setmem -1
	call @funcDeclGet +(FuncDecl.closure)
	getmem -1
	addSym
	leave 1
	ret 0

# string:func_name -> nil
funcDeclAddReturn:
	call @funcDeclGet dup 0 +(FuncDecl.returns) inc -(FuncDecl.returns)
	ret 0

# string:func_name -> nil
funcDeclEnter:
	enter 1
	call @funcDeclGet setmem -1
	+$local_dic_stack getmem -1 stackPush
	leave 1
	ret 0

funcDeclLeave:
	+$local_dic_stack stackPop
	ret 0

# string:symbol -> int:context (cf. symIs...)
getSymContext:
	enter 4
	setmem -1

	+$local_dic_stack stackSize [

		+$local_dic_stack stackPeek 0 setmem -2

		getmem -2 +(FuncDecl.locals) getmem -1 getSym setmem -3
		getmem -3 [ $symIsLocal leave 4 ret 0 ]

		getmem -2 +(FuncDecl.parameters) getmem -1 getSym setmem -3
		getmem -3 [ $symIsParam leave 4 ret 0 ]

		getmem -2 +(FuncDecl.closure) getmem -1 getSym setmem -3
		getmem -3 [ $symIsClosure leave 4 ret 0 ]

		push 0 setmem -4

	_context_loop:
		+$local_dic_stack stackSize getmem -4 eq [

			+$lical_dic_stack getmem -4 stackPeek setmem -2

			getmem -2 +(FuncDecl.locals) getmem -1 getSym setmem -3
			getmem -3 [ $symMustEnclose leave 4 ret 0 ]
	
			getmem -2 +(FuncDecl.parameters) getmem -1 getSym setmem -3
			getmem -3 [ $symMustEnclose leave 4 ret 0 ]
	
			getmem -2 +(FuncDecl.closure) getmem -1 getSym setmem -3
			getmem -3 [ $symMustEnclose leave 4 ret 0 ]

			getmem -4 inc setmem -4
			jmp @_context_loop
		]
	]

	+$glob_dic getmem -1 getSym setmem -3
	getmem -3 [ $symIsGlobal leave 4 ret 0 ]

	$symIsUnknown
	leave 4
	ret 0

_skip_0:nop
end

language
 hello ::= "Hello, world.".

 Script ::= "script" <script_loop>.
 script_loop = ( <script_statement> <script_loop> | "end" ).
 script_statement = ( <script_glob> | <script_fun> | <script_instruction> ).

 script_glob ::= "global" <script_sym_loop>.
 script_loc ::= "local" <script_sym_loop>.
 script_sym_loop = ( <sym> "," <script_sym_loop> | <sym> ).
 script_id ::= <sym>.
 script_string ::= <string>.

 script_fun ::= "function" <sym> <script_param_list> <script_fun_body>.
 script_param_list ::= "(" ( <script_sym_loop> ")" | ")" ).
 script_fun_body ::= ( <script_local> <sfb_loop> | <sfb_loop> ).
 sfb_loop = ( <script_instruction> <sfb_loop> | "end" ).
 script_local ::= "local" <script_sym_loop>.

 script_instruction = ( <script_if> | <script_while> | <script_assign> | <script_call> | <AsmBloc> | <script_print> | <script_return> ).

 script_while ::= "while" <b_expr> "do" <sub_bloc> "end".
 script_if ::= "if" <b_expr> "then" <sub_bloc> ( "else" <sub_bloc> "end" | "end" ).
 sub_bloc ::= <sbloop>.
 sbloop = ( <sbloop> <script_instruction> | <script_instruction> ).

 script_call ::= <sym> "(" <script_expr_loop>.
 script_expr_loop = <script_expr> ( "," <script_expr_loop> | ")" ).
 

 script_print ::= "print" <script_print_loop>.
 script_print_loop = ( <script_expr> "," <script_print_loop> | <script_expr> ).
 script_expr = ( <script_string> | <b_expr> ).

 script_return = "return" <script_expr>.

 script_assign ::= <sym> "=" ( <script_expr> ).

 script_int ::= <int>.
 script_float ::= <float>.
 number = ( <script_float> | <script_int> | <script_call> | <script_id> | "(" <m_expr> ")" ).

 m_expr ::= <expr4>.
 b_expr ::= <bexpr4>.

atom = ( <script_float> | <script_int> | <script_call> | <script_id> | "(" <script_expr> ")" ).

m_minus ::= "-" <number>.
m_div ::= ( <m_div> "/" <expr0> | <expr0> "/" <expr0> ).
m_mul ::= ( <m_mul> "*" <expr1> | <expr1> "*" <expr1> ).
m_sub ::= ( <m_sub> "-" <expr2> | <expr2> "-" <expr2> ).
m_add ::= ( <m_add> "+" <expr3> | <expr3> "+" <expr3> ).

b_not ::= "not" <m_expr>.
b_and ::= ( <b_and> "and" <bexpr1> | <bexpr1> "and" <bexpr1> ).
b_or ::= ( <b_or> "or" <bexpr2> | <bexpr2> "or" <bexpr2> ).

comp ::= <bexpr2> /(<|>|=|!=|>=|<=)/ <bexpr2>.

expr0 = ( <m_minus> | <number> ).
expr1 = ( <m_div> | <expr0> ).
expr2 = ( <m_mul> | <expr1> ).
expr3 = ( <m_sub> | <expr2> ).
expr4 = ( <m_add> | <expr3> ).

bexpr1 = ( <b_not> | <m_expr> ).
bexpr2 = ( <b_and> | <bexpr1> ).
bexpr3 = ( <b_or> | <bexpr2> ).

bexpr4 = ( <comp> | <bexpr2> ).

end



plug hello into p_Code
plug Script into p_Code

compile Script asm
	#pp_curNode
	compileStateDown
end



compile script_glob
asm
	#pp_curNode
	# size,counter
	enter 2
	# if(!node_opd_count) return
	astGetChildrenCount
	SNZ jmp @done_glob
	# size = node_opd_count
	astGetChildrenCount setmem -1
	# write("data 0 rep $size end")
	getmem -1 push 0 write_data
	# counter=0
	push 0 setmem -2
	# do {
fill_glob_dict:
	# addsym(node_childString(counter,dic)
	getmem 1 getmem -2 astGetChildString addSym
	# counter += 1
	getmem -2 inc setmem -2
	# } while(counter!=size)
	getmem -2 getmem -1 sub SZ jmp @fill_glob_dict
done_glob:
	leave 2
	compileStateNext
end


compile script_loc asm compileStateNext end


compile script_id
asm
	enter 1
#	+$cur_fname
	astGetChildString 0
	call @getSymContext 
	setmem -1
	getmem -1 $symIsLocal eq [[
		push 0
		+$call_local_ofs
		sub
		+$cur_fname call @funcDeclGet +(FuncDecl.locals)
		astGetChildString 0
		getSym
		sub
		write_oc_Int "getmem"
	][ getmem -1 $symIsParam eq [[
		push 0
		+$call_local_ofs
		sub
		+$cur_fname call @funcDeclGet +(FuncDecl.locals)
		symTabSz dec
		sub
		+$cur_fname call @funcDeclGet +(FuncDecl.parameters)
		astGetChildString 0
		getSym
		sub
		write_oc_Int "getmem"
	][ getmem -1 $symIsGlobal eq [[
			+$glob_dic
			astGetChildString 0
		getSym
		write_oc_Int "getmem"
	][ getmem -1 $symIsClosure eq [[
		push "Error : closures not yet implemented (can't handle symbol '"
		getmem -1
		push "')\n"
		print 3
	][ getmem -1 $symMushEnclose eq [[
		push "Error : closures not yet implemented (can't handle symbol '"
		getmem -1
		push "')\n"
		print 3
	][ getmem -1 $symUnknown eq [
		push "Error : symbol is unknown (can't handle symbol '"
		getmem -1
		push "')\n"
		print 3
	] ]] ]] ]] ]] ]]
	leave 1
	compileStateNext
done_id:
	compileStateNext
	ret 0
_id_no_def_error:
	compileStateError
	ret 1
end


compile script_print
asm
	# size,counter
	enter 2
	# if(!node_opd_count) return
	astGetChildrenCount
	SNZ jmp @done_print
	# size = node_opd_count
	astGetChildrenCount setmem -1
	# counter=0
	push 0 setmem -2
	# do {
fill_print:
	getmem -2 astCompileChild
	# counter += 1
	getmem -2 inc setmem -2
	# } while(counter!=size)
	getmem -2 getmem -1 sub SZ jmp @fill_print
done_print:
	astGetChildrenCount write_oc_Int "print"
	leave 2
	compileStateNext
end


compile script_assign
asm
	enter 1
	getmem 1 astGetChildString 0 getSym setmem -1
	# process righthand side
	astCompileChild 1
	# fetch memory location
	getmem -1 write_oc_Int "setmem"
	leave 1
	compileStateNext
end


compile script_return
asm
	pp_curNode
	# process righthand side
	astCompileChild 0
	push 0 write_oc_Int "ret"
	compileStateNext
end


compile script_string
asm
	astGetChildString 0
	write_oc_String "push"
	compileStateNext
end






compile script_fun
asm
	#pp_curNode
	enter 3
	astGetChildString 0 -$cur_fname
	+$cur_fname call @gen_label setmem -2
	push "endfun" call @gen_label setmem -3

	#push "start label \\\"" getmem -2 push "\\\"\\n" print 3
	#push "end label \\\"" getmem -3 push "\\\"\\n" print 3

	+$cur_fname
	call @newFuncDecl

	+$cur_fname
	call @funcDeclEnter

	getmem -3 write_oc_Label "jmp"
	getmem -2 write_label

	+$cur_fname call @funcDeclGet getmem -2 -(FuncDecl.label)

	doWalk "analyzeFuncDecl"

	+$cur_fname
	call @funcDeclGet
	+(FuncDecl.locals)
	symTabSz dec setmem -1
	getmem -1 [
		getmem -1
		write_oc_Int "enter"
	]

	# skip parameters list, directly compile body
	astCompileChild 2

	getmem -1 [
		getmem -1
		write_oc_Int "leave"
	]

	push 0 write_oc_Int "ret"
	getmem -3 write_label
	call @funcDeclLeave
	leave 3
	compileStateNext
end

compile script_fun_body asm compileStateDown end
compile script_local asm compileStateNext end

compile script_call
asm
	enter 3
	astGetChildString 0
	call @funcDeclGet
	setmem -1
	push 1
	setmem -2
	getmem -1
	+(FuncDecl.parameters)
	symTabSz dec setmem -3
	getmem -3 write_oc_Int "enter"
	getmem -3 +$call_local_ofs add -$call_local_ofs
_call_param_loop:
	getmem -2 astGetChildrenCount inf [
		getmem -2 astCompileChild
		push 0 getmem -2 sub write_oc_Int "setmem"
		getmem -2 inc setmem -2 jmp @_call_param_loop
	]
	getmem -1 +(FuncDecl.label) write_oc_Label "call"
	getmem -1
	getmem -3
	write_oc_Int "leave"
	+$call_local_ofs getmem -3 sub -$call_local_ofs
	leave 3
	compileStateNext
end



compile script_param_list
asm
	push "script:"
	astGetOp
	push ": Not implemented.\n"
	print 3
	compileStateNext
end


compile script_int
asm
	astGetChildString 0 toI
	write_oc_Int "push"
	compileStateNext
end


compile script_float
asm
	astGetChildString 0 toF
	write_oc_Float "push"
	compileStateNext
end


compile m_expr
asm
	#pp_curNode
	astCompileChild 0
	compileStateNext
end


compile b_expr
asm
	#pp_curNode
	astCompileChild 0
	compileStateNext
end


compile m_minus
asm
	push 0 write_oc_Int "push"
	astCompileChild 0
	write_oc "sub"
	compileStateNext
end


compile m_add
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "add"
	compileStateNext
end


compile m_sub
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "sub"
	compileStateNext
end


compile m_mul
asm
	#pp_curNode
	astCompileChild 0
	#pp_curNode
	astCompileChild 1
	write_oc "mul"
	compileStateNext
end


compile m_div
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "div"
	compileStateNext
end





compile b_and
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "and"
	compileStateNext
end


compile b_or
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "or"
	compileStateNext
end


compile b_not
asm
	astCompileChild 0
	write_oc "not"
	compileStateNext
end



compile comp
asm
	astCompileChild 0
	astCompileChild 2
	astGetChildString 1
	dup 0 push ">" strcmp [[
	dup 0 push "<" strcmp [[
	dup 0 push ">=" strcmp [[
	dup 0 push "<=" strcmp [[
	dup 0 push "=" strcmp [[
	dup 0 push "!=" strcmp [[
		push "Hey, unknown comp op '"
		astGetChildString 1
		push "' !\n"
		print 3
	][
		write_oc "nEq"
	]]
	][
		write_oc "eq"
	]]
	][
		write_oc "infEq"
	]]
	][
		write_oc "supEq"
	]]
	][
		write_oc "inf"
	]]
	][
		write_oc "sup"
	]]
	pop
	compileStateNext
end



compile script_if
asm
	astGetChildrenCount push 3 eq [[
		# if then else
		enter 4
		+$cur_fname strcat "_if" call @gen_label setmem -1
		+$cur_fname strcat "_then" call @gen_label setmem -2
		+$cur_fname strcat "_else" call @gen_label setmem -3
		+$cur_fname strcat "_endif" call @gen_label setmem -4

		getmem -1 write_label
		astCompileChild 0

		write_oc "SNZ"
		getmem -3
		write_oc_Label "jmp"

		getmem -2 write_label

		astCompileChild 1

		getmem -4 write_oc_Label "jmp"
		getmem -3 write_label

		astCompileChild 2

		getmem -4 write_label

		leave 4
	][
		# if then
		enter 3
		+$cur_fname strcat "_if" call @gen_label setmem -1
		+$cur_fname strcat "_then" call @gen_label setmem -2
		+$cur_fname strcat "_endif" call @gen_label setmem -3

		getmem -1 write_label
		astCompileChild 0

		write_oc "SNZ"
		getmem -3
		write_oc_Label "jmp"

		getmem -2 write_label

		astCompileChild 1

		getmem -3 write_label

		leave 3
	]]
	compileStateNext
end


compile script_while
asm

	# if then
	enter 2
	+$cur_fname strcat "_while" call @gen_label setmem -1
	+$cur_fname strcat "_endwhile" call @gen_label setmem -2

	getmem -1 write_label
	astCompileChild 0

	write_oc "SNZ"
	getmem -2
	write_oc_Label "jmp"

	astCompileChild 1

	getmem -1 write_oc_Label "jmp"

	getmem -2 write_label

	leave 2
	compileStateNext
end


compile sub_bloc asm compileStateDown end

