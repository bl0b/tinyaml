require "symasm.melang" glob

	glob_dic = 0
	func_dic = 0
	func_tab = 0
	local_dic_stack = 0
# for scope management :
	symIsLocal = 101
	symIsParam = 102
	symIsGlobal = 103
	symIsClosure = 104
	symMustEnclose = 105
	symUnknown = 106

	_sym_ofs = 0

	type_dic = 0
	type_tab = 0

	cur_fname = 0
	lbl_counter = 0

	call_local_ofs = 0
	is_lvalue = 0
	current_end_tc = 0
end


struc FuncDecl {
	returns		# int : maximum count of returned values
	parameters	# symtab : parameters
	locals		# symtab : local variables
	closure		# symtab : enclosed variables
	closure_ofs	# array : offsets of variables to clone in closure
	label		# string : start label
	has_vararg	# int : 0 if function doesn't use a variable argument
}


walker analyzeFuncDecl {

	init asm
		nop
	end

	terminate asm
		nop
	end

	default asm
		push "analyzeFuncDecl default on " astGetOp push "\\n" print 3
		compileStateNext
	end

	on script_fun_decl asm
		# process param list
		walkChild 0

		+$cur_fname
		call @funcDeclEnter

		# process body
		walkChild 1

		call @funcDeclLeave

		compileStateDone
	end

	on script_glob_fun asm walkChild 1 compileStateNext end
	on script_anon_fun asm compileStateDown end

	on script_var asm compileStateDown end
	on script_array_access asm compileStateDown end
	on script_struc_access asm compileStateNext end
	on script_throw asm compileStateNext end
	on script_try asm compileStateNext end


	on script_param_list asm
		local counter {				# counter
			push 0 -$counter
#			pp_curNode
		_spl_loop:
			+$counter astGetChildrenCount nEq [
				#+$cur_fname
				#+$counter
				#astGetChildString
				#call @funcDeclAddParam
				+$counter walkChild
				+$counter inc -$counter
				jmp @_spl_loop
			]
		}
		compileStateDone
	end

	on script_param asm +$cur_fname astGetChildString 0 call @funcDeclAddParam compileStateNext end
	on script_vararg asm +$cur_fname astGetChildString 0 call @funcDeclAddVararg compileStateNext end


	on script_local asm
		local counter {				# counter
			push 0 -$counter
		_sl_loop:
			+$counter astGetChildrenCount nEq [
				+$counter walkChild
				+$cur_fname
				astGetChildString
				call @funcDeclAddLocal
				+$counter inc -$counter
				jmp @_sl_loop
			]
		}
		compileStateNext
	end
	

	on script_id asm
		local sc {
			+$cur_fname
			astGetChildString 0
			call @getSymContext 
			-$sc
			+$sc $symIsLocal eq [
				nop
			]
			+$sc $symIsParam eq [
				nop
			]
			+$sc $symIsGlobal eq [
				nop
			]
			+$sc $symIsClosure eq [
				nop
			]
			+$sc $symMustEnclose eq [
				nop
	#			push "symbol must be enclosed\\n" print 1
			]
			+$sc $symUnknown eq [
				nop
	#			push "symbol is unknown\\n" print 1
			]
		}
		compileStateNext
	end


	on script_assign	asm compileStateDown end
	on script_fun_body	asm compileStateDown end
	on script_print		asm compileStateDown end
	on instruction_seq	asm compileStateDown end
	on m_expr		asm compileStateDown end
	on b_expr		asm compileStateDown end
	on comp			asm compileStateDown end
	on m_add		asm compileStateDown end
	on m_sub		asm compileStateDown end
	on m_mul		asm compileStateDown end
	on m_div		asm compileStateDown end
	on b_not		asm compileStateDown end
	on b_and		asm compileStateDown end
	on b_or			asm compileStateDown end
	on script_call		asm compileStateDown end
	on script_if		asm compileStateDown end
	on sb_end		asm compileStateDown end
	on sb_else		asm compileStateDown end
}

asm
	jmp @_skip_0

reset_tables:
	newSymTab -$glob_dic
	newSymTab -$func_dic
	arrayNew  -$func_tab
	+$func_tab push 0 push 0 arraySet
	stackNew -$local_dic_stack
	ret 0

# string:something -> string:label
gen_label:
	+$lbl_counter inc -$lbl_counter
	push "_" +$lbl_counter toS strcat strcat
	ret 0

newFuncDecl:
	local fname {
		# backup func name
		-$fname
		# insert symbol into tab
		+$func_dic
		+$fname
		addSym
		# add new func decl entry into tab
		+$func_tab
		# create structure
		strucNew FuncDecl {
			returns : push 0
			parameters : newSymTab
			locals : newSymTab
			closure : newSymTab
			closure_ofs : arrayNew
			label : push ""
			has_vararg : push 0
		}
		# fetch index of sym
		+$func_dic +$fname getSym
		arraySet
		pop
	}
	ret 0

funcDeclGet:
	local fname { -$fname
		+$func_tab
		+$func_dic +$fname getSym
		arrayGet
	}
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddParam:
	local pname { -$pname	# pop param name
		call @funcDeclGet +(FuncDecl.parameters)
		+$pname
		addSym
	}
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddVararg:
	local fname {
		dup -1 -$fname
		call @funcDeclAddParam
		+$fname call @funcDeclGet push 1 -(FuncDecl.has_vararg)
	}
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddLocal:
	local pname {
		# pop param name
		-$pname
		call @funcDeclGet +(FuncDecl.locals)
		+$pname
		addSym
	}
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddClosure:
	local pname {
		# pop param name
		-$pname
		call @funcDeclGet +(FuncDecl.closure)
		+$pname
		addSym
	}
	ret 0

# string:func_name -> nil
funcDeclAddReturn:
	call @funcDeclGet dup 0 +(FuncDecl.returns) inc -(FuncDecl.returns)
	ret 0

# string:func_name -> nil
funcDeclEnter:
	local fdecl {
		call @funcDeclGet -$fdecl
		+$local_dic_stack +$fdecl stackPush
	}
	ret 0

funcDeclLeave:
	+$local_dic_stack stackPop
	ret 0

# string:symbol -> int:context (cf. symIs...)
getSymContext:
	local symbol, locdic, symofs, counter, backup {
	-$symbol

	push 0 -$_sym_ofs

###	push "entering getSymContext... " +$local_dic_stack stackSize push "\\n" print 3

	+$local_dic_stack stackSize [

###		push "entering local context...\\n" print 1

		+$local_dic_stack stackPeek 0 -$locdic
		+$locdic -$backup

		+$locdic +(FuncDecl.locals) +$symbol getSym -$symofs
		+$symofs [
			push 0 +$symofs sub +$call_local_ofs sub -$_sym_ofs
###			push "Symbol '" +$symbol push "' is local at ofs " +$_sym_ofs push "\\n" print 5
			$symIsLocal jmp @_sc_ret ]

		+$locdic +(FuncDecl.parameters) +$symbol getSym -$symofs
		+$symofs [
			push 0 +$locdic +(FuncDecl.locals) symTabSz dec sub +$symofs sub +$call_local_ofs sub -$_sym_ofs
###			push "Symbol '" +$symbol push "' is a parameter at ofs " +$_sym_ofs push "\\n" print 5
			$symIsParam jmp @_sc_ret ]

		+$locdic +(FuncDecl.closure) +$symbol getSym -$symofs
		+$symofs [
			+$symofs dec -$_sym_ofs
###			push "Symbol '" +$symbol push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
			$symIsClosure jmp @_sc_ret ]

		push 0 -$counter

		push 0 +$call_local_ofs sub
#		+$locdic +(FuncDecl.locals) symTabSz dec
#		+$locdic +(FuncDecl.parameters) symTabSz dec
#		add sub
		-$_sym_ofs

		+$counter inc -$counter

	_context_loop:
		+$local_dic_stack stackSize +$counter sup [

###			push "entering local sub-context #" +$counter push "...\\n" print 3
###			push "base _sym_ofs is " +$_sym_ofs push "\\n" print 3

			+$local_dic_stack +$counter stackPeek -$locdic

			+$locdic +(FuncDecl.locals) +$symbol getSym -$symofs
			+$symofs [
				+$backup +(FuncDecl.closure) +$symbol addSym
				+$backup +(FuncDecl.closure_ofs)
					+$_sym_ofs
					+$symofs
					sub -$_sym_ofs
					+$_sym_ofs
					+$backup +(FuncDecl.closure_ofs) arraySize
				arraySet
#				push "Symbol local '" +$symbol push "' outbound ofs is " +$_sym_ofs push "\\n" print 5
				+$backup +(FuncDecl.closure) +$symbol getSym dec -$_sym_ofs
#				push "Symbol '" +$symbol push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
				$symIsClosure jmp @_sc_ret ]
	
			+$locdic +(FuncDecl.parameters) +$symbol getSym -$symofs
			+$symofs [
				+$backup +(FuncDecl.closure) +$symbol addSym
				+$backup +(FuncDecl.closure_ofs)
					+$_sym_ofs
					+$locdic +(FuncDecl.locals) symTabSz dec
					sub
					+$symofs dec
					sub -$_sym_ofs
					+$_sym_ofs
					+$backup +(FuncDecl.closure_ofs) arraySize
				arraySet
#				push "Symbol param '" +$symbol push "' outbound ofs is " +$_sym_ofs push "\\n" print 5
				+$backup +(FuncDecl.closure) +$symbol getSym dec -$_sym_ofs
#				push "Symbol '" +$symbol push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
				$symIsClosure jmp @_sc_ret ]
	
			+$locdic +(FuncDecl.closure) +$symbol getSym dec -$symofs
			+$symofs push -1 sup [
				push "Error : enclosed closure for '" +$symbol push "', offset " +$symofs push ". can't handle that yet.\n" print 5
				$symMustEnclose jmp @_sc_ret ]

			+$_sym_ofs
			+$locdic +(FuncDecl.locals) symTabSz dec
			+$locdic +(FuncDecl.parameters) symTabSz dec
			add sub
			-$_sym_ofs

			+$counter inc -$counter
			jmp @_context_loop
		]
	]

	+$glob_dic +$symbol getSym -$symofs
	+$symofs [
		+$symofs -$_sym_ofs
###		push "Symbol '" +$symbol push "' is global at ofs " +$_sym_ofs push "\\n" print 5
		$symIsGlobal jmp @_sc_ret ]

	$symUnknown
_sc_ret:}
	ret 0

_skip_0:
end

language

 Script ::= "script" script_glob script_statement+ "end".
 script_statement = ( script_glob_fun | script_instruction ).

 script_glob ::= ("global" sym ("," sym)*|_epsilon).
 script_loc ::= "local"  sym ("," sym)*.
 script_id ::= sym.
 script_string ::= string.

 script_glob_fun ::= "function" sym script_fun_decl.
 script_anon_fun ::= "function" script_fun_decl.
 script_fun_decl ::= script_param_list script_fun_body.
 script_param_list ::= "(" ( ")" | (script_param ",")* ( script_vararg | script_param ) ")" ).
 script_param ::= sym.
 script_vararg ::= sym "...".
 script_fun_body ::= script_local? script_instruction+ "end".
 script_local ::= "local" sym ("," sym)*.

 script_instruction = ( script_if | script_while | AsmBloc | script_print | script_return | script_throw | script_try | script_assign | script_call ).
 instruction_seq = script_instruction+.
 instruction_bloc ::= instruction_seq.

 script_try ::= "try" instruction_bloc "catch" catch_bloc.
 catch_bloc ::= catch_bloc_loop.
 catch_bloc_loop = ( catch_statement catch_bloc_loop | "end" ).
 catch_statement ::= sym ":" instruction_bloc.
 script_throw ::= "throw" sym.

 script_while ::= "while" b_expr "do" sb_end.
 script_if ::= "if" b_expr "then" ( sb_else sb_end | sb_end ).

 sb_end ::= sbloop_end.
 sb_else ::= sbloop_else.
 sbloop_end = ( script_instruction sbloop_end | "end" ).
 sbloop_else = ( script_instruction sbloop_else | "else" ).

 script_call ::= script_var "(" ( ")" | script_expr_loop ).
 script_expr_loop = script_expr ( "," script_expr_loop | ")" ).
 

 script_print ::= "print" script_print_loop.
 script_print_loop = ( script_expr "," script_print_loop | script_expr ).
 script_expr = ( script_string | script_anon_fun | b_expr | m_expr ).

 script_return ::= "return" script_expr.

 script_assign ::= script_var "=" ( script_expr ).

 script_int ::= int.
 script_float ::= float.
 number = ( script_float | script_int | script_call | script_var | "(" m_expr ")" ).

 script_var ::= ( script_var (script_array_access|script_struc_access) | ( script_env |script_id )).

 script_env ::= "&" sym.

 script_array_access ::= "[" m_expr "]".
 script_struc_access ::= "." sym.

 m_expr = expr4.
 b_expr = bexpr4.

atom = ( script_float | script_int | script_call | script_var | "(" script_expr ")" ).

m_minus ::= "-" number.
m_div ::= ( m_div "/" expr0 | expr0 "/" expr0 ).
m_mul ::= ( m_mul "*" expr1 | expr1 "*" expr1 ).
m_sub ::= ( m_sub "-" expr2 | expr2 "-" expr2 ).
m_add ::= ( m_add "+" expr3 | expr3 "+" expr3 ).

b_not ::= "not" m_expr.
b_and ::= ( b_and "and" bexpr1 | bexpr1 "and" bexpr1 ).
b_or ::= ( b_or "or" bexpr2 | bexpr2 "or" bexpr2 ).

comp ::= bexpr2 /(<|>|=|!=|>=|<=)/ bexpr2.

expr0 = ( m_minus | number ).
expr1 = ( m_div | expr0 ).
expr2 = ( m_mul | expr1 ).
expr3 = ( m_sub | expr2 ).
expr4 = ( m_add | expr3 ).

bexpr1 = ( b_not | m_expr ).
bexpr2 = ( b_and | bexpr1 ).
bexpr3 = ( b_or | bexpr2 ).

bexpr4 = ( comp | bexpr2 ).

end


plug Script into p_Code



compile Script asm
	#pp_curNode
	compileStateDown
end

compile instruction_bloc asm compileStateDown end


compile script_throw asm
	<< push s(astGetChildString 0) throw >>
	compileStateNext
end


compile script_try asm
	local try_lbl, catch_lbl, end_lbl {
		push "try" call @gen_label -$try_lbl
		push "catch" call @gen_label -$catch_lbl
		push "end_trycatch" call @gen_label -$end_lbl

		# try: instCatcher @catch
		<< (+$try_lbl): instCatcher l(+$catch_lbl) >>
		# ...
		astCompileChild 0
		# jmp @end_trycatch catch:
		<< uninstCatcher l(+$end_lbl) (+$catch_lbl): >>
		# ...
		+$end_lbl -$current_end_tc
		astCompileChild 1
		# end_trycatch:
		<< (+$end_lbl): >>
	}
	compileStateNext
end


compile catch_statement asm
	local end_lbl {
		push "endcatch_" astGetChildString 0 strcat call @gen_label -$end_lbl
		<< getException strcmp s(astGetChildString 0) SZ jmp l(+$end_lbl) >>
		astCompileChild 1
		<< jmp l(+$current_end_tc) (+$end_lbl): >>
	}
	compileStateNext
end

compile catch_bloc asm
	local counter {
		push 0 -$counter
	catch_bloc_loop:
		+$counter astGetChildrenCount inf [
			+$counter astCompileChild
			+$counter inc -$counter
			jmp @catch_bloc_loop
		]

		# default: propagate exception
		<< getException throw >>
	}
	compileStateNext
end


compile script_glob
asm
	call @reset_tables
	#pp_curNode
	# size,counter
	local size, counter {
		# if(!node_opd_count) return
		astGetChildrenCount
		SNZ jmp @done_glob
		# size = node_opd_count
		astGetChildrenCount -$size
		# write("data 0 rep $size end")
		+$size push 0 write_data
		# counter=0
		push 0 -$counter
		# do {
	fill_glob_dict:
		# addsym(node_childString(counter,dic)
		push "fill glob #" +$counter push "\\n" print 3
		+$glob_dic +$counter astGetChildString addSym
		# counter += 1
		+$counter inc -$counter
		# } while(counter<size)
		+$counter +$size inf SZ jmp @fill_glob_dict
	done_glob:
	}
	compileStateNext
end


compile script_glob_fun
asm
	local sz {
		#pp_curNode
		+$glob_dic astGetChildString 0 getSym [
			push "Symbol " astGetChildString 0 push "\ already defined !\n" print 3
			compileStateError
			ret 0
		]

		astGetChildString 0 -$cur_fname

		push 1 push 0 write_data
		#+$glob_dic symTabSz -$sz
		+$glob_dic
		#+$sz
		+$cur_fname
		addSym
		+$glob_dic +$cur_fname getSym -$sz

		# do "cur_fname = ...fun..."
		astCompileChild 1

	#	push "Symbol '" +$cur_fname push "' has index " +$sz push "\\n" print 5

		<< setmem i(+$sz) >>

		push "" -$cur_fname
	}
	compileStateNext
end

compile script_anon_fun
asm
	+$call_local_ofs
		push 0 -$call_local_ofs
		push "anon" call @gen_label -$cur_fname
		astCompileChild 0
		push "" -$cur_fname
	-$call_local_ofs
	compileStateNext
end


compile script_fun_decl
asm
	#pp_curNode
#	push "@@@   at start, $cur_fname = " +$cur_fname push "   @@@\\n" print 3
	local locsz, fun_lbl, endfun_lbl, fname_backup, supargc, argc {
		+$cur_fname call @gen_label -$fun_lbl
		push "endfun" call @gen_label -$endfun_lbl

		#push "start label \\\"" +$fun_lbl push "\\\"\\n" print 3
		#push "end label \\\"" -$enfdun_lbl push "\\\"\\n" print 3

		+$cur_fname
		call @newFuncDecl

		+$cur_fname
		call @funcDeclEnter

		<< jmp l(+$endfun_lbl) (+$fun_lbl): >>

		+$cur_fname call @funcDeclGet +$fun_lbl -(FuncDecl.label)

		+$cur_fname -$fname_backup

		doWalk "analyzeFuncDecl"

		+$fname_backup -$cur_fname

		# insert function header
		#	- if no vararg : check against dynamic argc, throw badarg if nEq
		#	- if vararg : compute supplementary argc, copy sup' args into an array, install the array as last arg
		# first, code to fetch dynamic argc
		+$cur_fname call @funcDeclGet +(FuncDecl.has_vararg) [[
			nop
	#		-$argc
	#		+$argc
	#		# compute supargc
	#		+$cur_fname call @funcDeclGet +(FuncDecl.parameters) sub 2 -$supargc
	#		# check that supargc>=0
	#		+$supargc write_ocInt "supEq"
	#
	#		# prepare array counter max
	#		+$argc
	#		+$supargc
	#		sub
	#
	#		# throw if failed
	#		push "check_argc_pass" call @gen_label -$supargc
	#		write_oc "SZ"
	#		+$supargc write_ocLabel "jmp"
	#		push "WrongParameterCount" write_oc "throw"
	#		+$supargc write_label
	#
	#	+$cur_fname push "_vastart_loop" strcat -$endfun_lbl
	#	# start count
	#<<
	#	enter 2
	#	arrayNew
	#	arrayResv (+$argc)
	#	-$fun_lbl
	#	push 0 -$locsz
	#	# get -1-count -th arg
	#(:	+$fun_lbl 
	#	push -1 +$locsz sub getmem
	#	+$locsz
	#	arraySet
	#	+$locsz inc -$locsz
	#	+$locsz inf (+$argc) SZ jmp @_loop
	#>>	
	#
	#
	#
	#		# store array counter max
	#		-$supargc
	#		# now copy
	#		push 1 write_ocInt "enter"
	#		push 0 write_ocInt "push"
	#		push -1 write_
	#		push 1 write_ocInt "leave"
			

		][
			push "check_argc_pass" call @gen_label -$supargc
			# throw if failed
			<< push i( +$cur_fname call @funcDeclGet +(FuncDecl.parameters) symTabSz dec)
			   eq
			   SZ
			   jmp l(+$supargc)
			   push "WrongParameterCount"
			   throw
			   (+$supargc):
			>>
		]]


		+$cur_fname
		call @funcDeclGet
		+(FuncDecl.locals)
		symTabSz dec -$locsz
		+$locsz [
			+$locsz
			write_ocInt "enter"
		]

		# skip parameters list, directly compile body
		astCompileChild 1

		+$fname_backup -$cur_fname

		+$locsz [
			+$locsz
			write_ocInt "leave"
		]

		push 0 write_ocInt "ret"
		+$endfun_lbl write_label
		call @funcDeclLeave
		+$fun_lbl write_ocLabel "dynFunNew"

		push 0 -$locsz
	#	push "\   @@@   NOW $cur_fname = " +$cur_fname push "   @@@\\n" print 3
		+$cur_fname call @funcDeclGet +(FuncDecl.closure_ofs) -$fun_lbl
	_addcls_loop:
		+$fun_lbl arraySize +$locsz sup [
			+$fun_lbl +$locsz arrayGet write_ocInt "getmem"
			write_oc "dynFunAddClosure"
			+$locsz inc -$locsz
			jmp @_addcls_loop
		]

	}
	compileStateNext
end

compile script_fun_body asm compileStateDown end
compile script_local asm compileStateNext end

compile script_call
asm
	local counter, max {

		# push argc for use in function header
		astGetChildrenCount dec write_ocInt "push"

		astCompileChild 0
		push 1
		-$counter
		astGetChildrenCount dec -$max
		+$max [ +$max write_ocInt "enter" ]
		+$max +$call_local_ofs add -$call_local_ofs
	_call_param_loop:
		+$counter astGetChildrenCount inf [
			+$counter astCompileChild
			push 0 +$counter sub write_ocInt "setmem"
			+$counter inc -$counter jmp @_call_param_loop
		]

		write_oc "call"
		+$max [ +$max write_ocInt "leave" ]
		+$call_local_ofs +$max sub -$call_local_ofs
	}
	compileStateNext
end



compile script_loc asm compileStateNext end


compile script_id
asm
	local symctxt {
	#	+$cur_fname
		astGetChildString 0
		call @getSymContext -$symctxt
				+$symctxt $symIsLocal eq
				+$symctxt $symIsGlobal eq
			or
			+$symctxt $symIsParam eq
		or [[
			+$is_lvalue [[
				+$_sym_ofs
				write_ocInt "setmem"
				push 0 -$is_lvalue
			][
				+$_sym_ofs
				write_ocInt "getmem"
			]]
			compileStateNext
		][
			+$symctxt $symIsClosure eq [[
				+$is_lvalue [[
					+$_sym_ofs
					write_ocInt "setClosure"
					push 0 -$is_lvalue
				][
					+$_sym_ofs
					write_ocInt "getClosure"
				]]
				compileStateNext
			][
				push "At " astGetRow push ":" astGetCol push "\\t: " print 5
				push "Error with symbol context for sym '" astGetChildString 0 push "' : " print 3
				+$symctxt $symMustEnclose eq [ push "can't handle recursive closures yet\n" print 1]
				+$symctxt $symUnknown eq [ push "symbol is unknown.\n" print 1]
				compileStateError
			]]
		]]
	}
end


compile script_print
asm
	# size,counter
	local size, counter {
		# if(!node_opd_count) return
		astGetChildrenCount
		SNZ jmp @done_print
		# size = node_opd_count
		astGetChildrenCount -$size
		# counter=0
		push 0 -$counter
		# do {
	fill_print:
		+$counter astCompileChild
		# counter += 1
		+$counter inc -$counter
		# } while(counter!=size)
		+$counter +$size inf SZ jmp @fill_print
	done_print:
		astGetChildrenCount write_ocInt "print"
	}
	compileStateNext
end


compile script_assign
asm
	#pp_curNode
	local sym {
		#getmem 1 astGetChildString 0 getSym -$sym
		# process righthand side
		astCompileChild 1
		# process lefthand side
		push 1 -$is_lvalue
		astCompileChild 0
	}
	compileStateNext
end


compile script_return
asm
	#pp_curNode
	# process righthand side
	astCompileChild 0
	push 0 write_ocInt "ret"
	compileStateNext
end


compile script_string
asm
	astGetChildString 0
	write_ocString "push"
	compileStateNext
end



compile script_param_list
asm
	push "script:"
	astGetOp
	push ": Not implemented.\n"
	print 3
	compileStateNext
end


compile script_int
asm
	astGetChildString 0 toI
	write_ocInt "push"
	compileStateNext
end


compile script_float
asm
	astGetChildString 0 toF
	write_ocFloat "push"
	compileStateNext
end


#compile m_expr
#asm
#	#pp_curNode
#	astCompileChild 0
#	compileStateNext
#end


#compile b_expr
#asm
#	#pp_curNode
#	astCompileChild 0
#	compileStateNext
#end


compile m_minus
asm
	push 0 write_ocInt "push"
	astCompileChild 0
	write_oc "sub"
	compileStateNext
end


compile m_add
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "add"
	compileStateNext
end


compile m_sub
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "sub"
	compileStateNext
end


compile m_mul
asm
	#pp_curNode
	astCompileChild 0
	#pp_curNode
	astCompileChild 1
	write_oc "mul"
	compileStateNext
end


compile m_div
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "div"
	compileStateNext
end





compile b_and
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "and"
	compileStateNext
end


compile b_or
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "or"
	compileStateNext
end


compile b_not
asm
	astCompileChild 0
	write_oc "not"
	compileStateNext
end



compile comp
asm
	astCompileChild 0
	astCompileChild 2
	astGetChildString 1
	dup 0 push ">" strcmp [[
	dup 0 push "<" strcmp [[
	dup 0 push ">=" strcmp [[
	dup 0 push "<=" strcmp [[
	dup 0 push "=" strcmp [[
	dup 0 push "!=" strcmp [[
		push "Hey, unknown comp op '"
		astGetChildString 1
		push "' !\n"
		print 3
	][
		write_oc "nEq"
	]]
	][
		write_oc "eq"
	]]
	][
		write_oc "infEq"
	]]
	][
		write_oc "supEq"
	]]
	][
		write_oc "inf"
	]]
	][
		write_oc "sup"
	]]
	pop
	compileStateNext
end



compile script_if
asm
	astGetChildrenCount push 3 eq [[
		# if then else
		local if_lbl, then_lbl, else_lbl, endif_lbl {
			+$cur_fname strcat "_if" call @gen_label -$if_lbl
			+$cur_fname strcat "_then" call @gen_label -$then_lbl
			+$cur_fname strcat "_else" call @gen_label -$else_lbl
			+$cur_fname strcat "_endif" call @gen_label -$endif_lbl

			<< (+$if_lbl): >>
			astCompileChild 0
			<< SNZ jmp l(+$else_lbl) (+$then_lbl): >>
			astCompileChild 1
			<< jmp l(+$endif_lbl) (+$else_lbl): >>
			astCompileChild 2
			<< (+$endif_lbl): >>
		}
	][
		# if then
		local if_lbl, then_lbl, endif_lbl {
			+$cur_fname strcat "_if" call @gen_label -$if_lbl
			+$cur_fname strcat "_then" call @gen_label -$then_lbl
			+$cur_fname strcat "_endif" call @gen_label -$endif_lbl

			<< (+$if_lbl): >>
			astCompileChild 0
			<< SNZ jmp l(+$endif_lbl) (+$then_lbl): >>
			astCompileChild 1
			<< (+$endif_lbl): >>
		}
	]]
	compileStateNext
end


compile script_while
asm

	local while_lbl, endwhile_lbl {
		+$cur_fname strcat "_while" call @gen_label -$while_lbl
		+$cur_fname strcat "_endwhile" call @gen_label -$endwhile_lbl

		<< (+$while_lbl): >>
		astCompileChild 0
		<< SNZ jmp l(+$endwhile_lbl) >>
		astCompileChild 1
		<< jmp l(+$while_lbl) (+$endwhile_lbl): >>
	}
	compileStateNext
end


compile sb_end asm compileStateDown end
compile sb_else asm compileStateDown end

compile script_var asm
	+$is_lvalue astGetChildrenCount push 2 eq and [[
		push 0 -$is_lvalue
		astCompileChild 0
		push 1 -$is_lvalue
		astCompileChild 1
		compileStateNext
		push 0 -$is_lvalue
	][
		compileStateDown
	]]
end


compile script_env asm
	+$is_lvalue [[
		astGetChildString 0
		write_ocEnvSym "envSet"
		push 0 -$is_lvalue
	][
		astGetChildString 0
		write_ocEnvSym "envGet"
	]]
	compileStateNext
end


compile script_array_access asm
	+$is_lvalue [[
		push 0 -$is_lvalue
		push -1 write_ocInt "dup"
		astCompileChild 0
		write_oc "arraySet"
		push 2
		write_ocInt "pop"
	][
		astCompileChild 0
		write_oc "arrayGet"
	]]
	compileStateNext
end

compile script_struc_access asm
	astGetChildString 0
	+$is_lvalue [[
		write_ocString "mapSet"
		push 0 -$is_lvalue
	][
		write_ocString "mapGet"
	]]
	compileStateNext
end

