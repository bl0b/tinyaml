require "struc.melang"

glob
	glob_dic = 0
	func_dic = 0
	func_tab = 0
	local_dic_stack = 0
# for scope management :
	symIsLocal = 101
	symIsParam = 102
	symIsGlobal = 103
	symIsClosure = 104
	symMustEnclose = 105
	symUnknown = 106

	_sym_ofs = 0

	type_dic = 0
	type_tab = 0

	cur_fname = 0
	lbl_counter = 0

	call_local_ofs = 0
	is_lvalue = 0
end


struc FuncDecl {
	returns		# int : maximum count of returned values
	parameters	# symtab : parameters
	locals		# symtab : local variables
	closure		# symtab : enclosed variables
	closure_ofs	# array : offsets of variables to clone in closure
	label		# string : start label
}


walker analyzeFuncDecl {

	init asm
		nop
	end

	terminate asm
		nop
	end

	default asm
#		push "analyzeFuncDecl default on " astGetOp push "\\n" print 3
		compileStateNext
	end

	on script_fun_decl asm
		# process param list
		walkChild 0

		+$cur_fname
		call @funcDeclEnter

		# process body
		walkChild 1

		call @funcDeclLeave

		compileStateDone
	end

	on script_glob_fun asm walkChild 1 compileStateNext end
	on script_anon_fun asm compileStateDown end

	on script_var asm compileStateDown end
	on script_array_access asm compileStateDown end
	on script_struc_access asm compileStateNext end


	on script_param_list asm
		enter 1				# counter
		push 0 setmem -1
#		pp_curNode
	_spl_loop:
		getmem -1 astGetChildrenCount nEq [
			+$cur_fname
			getmem -1
			astGetChildString
			call @funcDeclAddParam
			getmem -1 inc setmem -1
			jmp @_spl_loop
		]
		leave 1
		compileStateDone
	end


	on script_local asm
		enter 1				# counter
		push 0 setmem -1
	_sl_loop:
		getmem -1 astGetChildrenCount nEq [
			+$cur_fname
			getmem -1
			astGetChildString
			call @funcDeclAddLocal
			getmem -1 inc setmem -1
			jmp @_sl_loop
		]
		leave 1
		compileStateNext
	end

	on script_id asm
		enter 1
		+$cur_fname
		astGetChildString 0
		call @getSymContext 
		setmem -1
		getmem -1 $symIsLocal eq [
			nop
		]
		getmem -1 $symIsParam eq [
			nop
		]
		getmem -1 $symIsGlobal eq [
			nop
		]
		getmem -1 $symIsClosure eq [
			nop
		]
		getmem -1 $symMustEnclose eq [
			nop
#			push "symbol must be enclosed\\n" print 1
		]
		getmem -1 $symUnknown eq [
			nop
#			push "symbol is unknown\\n" print 1
		]
		leave 1
		compileStateNext
	end


	on script_assign asm
		compileStateDown
		ret 0

#		enter 1
#		+$cur_fname
#		astGetChildString 0
#		call @getSymContext 
#		setmem -1
#		getmem -1 $symIsLocal eq [
#			nop
#		]
#		getmem -1 $symIsParam eq [
#			nop
#		]
#		getmem -1 $symIsGlobal eq [
#			nop
#		]
#		getmem -1 $symIsClosure eq [
#			nop
#		]
#		getmem -1 $symMustEnclose eq [
#			push "symbol must be enclosed\\n" print 1
#		]
#		getmem -1 $symUnknown eq [
#			push "symbol is unknown\\n" print 1
#		]
#		walkChild 1
#		leave 1
#		compileStateNext
	end


	on script_fun_body asm compileStateDown end

	on script_print asm compileStateDown end

	on m_expr asm compileStateDown end
	on b_expr asm compileStateDown end
	on comp asm compileStateDown end
	on m_add asm compileStateDown end
	on m_sub asm compileStateDown end
	on m_mul asm compileStateDown end
	on m_div asm compileStateDown end
	on b_not asm compileStateDown end
	on b_and asm compileStateDown end
	on b_or asm compileStateDown end
	on script_call asm compileStateDown end
	on script_if asm compileStateDown end
	on sb_end asm compileStateDown end
	on sb_else asm compileStateDown end
}

asm
	newSymTab -$glob_dic
	newSymTab -$func_dic
	arrayNew  -$func_tab
	+$func_tab push 0 push 0 arraySet
	stackNew -$local_dic_stack
	jmp @_skip_0

# string:something -> string:label
gen_label:
	+$lbl_counter inc -$lbl_counter
	push "_" +$lbl_counter toS strcat strcat
	ret 0

newFuncDecl:
	enter 1
	# backup func name
	setmem -1
	# insert symbol into tab
	+$func_dic
	getmem -1
	addSym
	# add new func decl entry into tab
	+$func_tab
	# create structure
	strucNew FuncDecl {
		returns : push 0
		parameters : newSymTab
		locals : newSymTab
		closure : newSymTab
		closure_ofs : arrayNew
		label : push ""
	}
	# fetch index of sym
	+$func_dic getmem -1 getSym
	arraySet
	pop
	leave 1
	ret 0

funcDeclGet:
	enter 1 setmem -1
	+$func_tab
	+$func_dic getmem -1 getSym
	arrayGet
	leave 1
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddParam:
	enter 1
	# pop param name
	setmem -1
	call @funcDeclGet +(FuncDecl.parameters)
	getmem -1
	addSym
	leave 1
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddLocal:
	enter 1
	# pop param name
	setmem -1
	call @funcDeclGet +(FuncDecl.locals)
	getmem -1
	addSym
	leave 1
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddClosure:
	enter 1
	# pop param name
	setmem -1
	call @funcDeclGet +(FuncDecl.closure)
	getmem -1
	addSym
	leave 1
	ret 0

# string:func_name -> nil
funcDeclAddReturn:
	call @funcDeclGet dup 0 +(FuncDecl.returns) inc -(FuncDecl.returns)
	ret 0

# string:func_name -> nil
funcDeclEnter:
	enter 1
	call @funcDeclGet setmem -1
	+$local_dic_stack getmem -1 stackPush
	leave 1
	ret 0

funcDeclLeave:
	+$local_dic_stack stackPop
	ret 0

# string:symbol -> int:context (cf. symIs...)
getSymContext:
	enter 5
	setmem -1

	push 0 -$_sym_ofs

###	push "entering getSymContext... " +$local_dic_stack stackSize push "\\n" print 3

	+$local_dic_stack stackSize [

###		push "entering local context...\\n" print 1

		+$local_dic_stack stackPeek 0 setmem -2
		getmem -2 setmem -5

		getmem -2 +(FuncDecl.locals) getmem -1 getSym setmem -3
		getmem -3 [
			push 0 getmem -3 sub +$call_local_ofs sub -$_sym_ofs
###			push "Symbol '" getmem -1 push "' is local at ofs " +$_sym_ofs push "\\n" print 5
			$symIsLocal leave 5 ret 0 ]

		getmem -2 +(FuncDecl.parameters) getmem -1 getSym setmem -3
		getmem -3 [
			push 0 getmem -2 +(FuncDecl.locals) symTabSz dec sub getmem -3 sub +$call_local_ofs sub -$_sym_ofs
###			push "Symbol '" getmem -1 push "' is a parameter at ofs " +$_sym_ofs push "\\n" print 5
			$symIsParam leave 5 ret 0 ]

		getmem -2 +(FuncDecl.closure) getmem -1 getSym setmem -3
		getmem -3 [
			getmem -3 dec -$_sym_ofs
###			push "Symbol '" getmem -1 push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
			$symIsClosure leave 5 ret 0 ]

		push 0 setmem -4

		push 0 +$call_local_ofs sub
#		getmem -2 +(FuncDecl.locals) symTabSz dec
#		getmem -2 +(FuncDecl.parameters) symTabSz dec
#		add sub
		-$_sym_ofs

		getmem -4 inc setmem -4

	_context_loop:
		+$local_dic_stack stackSize getmem -4 sup [

###			push "entering local sub-context #" getmem -4 push "...\\n" print 3
###			push "base _sym_ofs is " +$_sym_ofs push "\\n" print 3

			+$local_dic_stack getmem -4 stackPeek setmem -2

			getmem -2 +(FuncDecl.locals) getmem -1 getSym setmem -3
			getmem -3 [
				getmem -5 +(FuncDecl.closure) getmem -1 addSym
				getmem -5 +(FuncDecl.closure_ofs)
					+$_sym_ofs
					getmem -3
					sub -$_sym_ofs
					+$_sym_ofs
					getmem -5 +(FuncDecl.closure_ofs) arraySize
				arraySet
#				push "Symbol local '" getmem -1 push "' outbound ofs is " +$_sym_ofs push "\\n" print 5
				getmem -5 +(FuncDecl.closure) getmem -1 getSym dec -$_sym_ofs
#				push "Symbol '" getmem -1 push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
				$symIsClosure leave 5 ret 0 ]
	
			getmem -2 +(FuncDecl.parameters) getmem -1 getSym setmem -3
			getmem -3 [
				getmem -5 +(FuncDecl.closure) getmem -1 addSym
				getmem -5 +(FuncDecl.closure_ofs)
					+$_sym_ofs
					getmem -2 +(FuncDecl.locals) symTabSz dec
					sub
					getmem -3 dec
					sub -$_sym_ofs
					+$_sym_ofs
					getmem -5 +(FuncDecl.closure_ofs) arraySize
				arraySet
#				push "Symbol param '" getmem -1 push "' outbound ofs is " +$_sym_ofs push "\\n" print 5
				getmem -5 +(FuncDecl.closure) getmem -1 getSym dec -$_sym_ofs
#				push "Symbol '" getmem -1 push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
				$symIsClosure leave 5 ret 0 ]
	
			getmem -2 +(FuncDecl.closure) getmem -1 getSym dec setmem -3
			getmem -3 push -1 sup [
				push "Error : enclosed closure for '" getmem -1 push "', offset " getmem -3 push ". can't handle that yet.\n" print 5
				$symMustEnclose leave 5 ret 0 ]

			+$_sym_ofs
			getmem -2 +(FuncDecl.locals) symTabSz dec
			getmem -2 +(FuncDecl.parameters) symTabSz dec
			add sub
			-$_sym_ofs

			getmem -4 inc setmem -4
			jmp @_context_loop
		]
	]

	+$glob_dic getmem -1 getSym setmem -3
	getmem -3 [
		getmem -3 -$_sym_ofs
###		push "Symbol '" getmem -1 push "' is global at ofs " +$_sym_ofs push "\\n" print 5
		$symIsGlobal leave 5 ret 0 ]

	$symUnknown
	leave 5
	ret 0

getSymOffset:
	enter 1
	call @getSymContext 
	setmem -1
	getmem -1 $symIsLocal eq [[
		push 0
		+$call_local_ofs
		sub
		+$cur_fname call @funcDeclGet +(FuncDecl.locals)
		astGetChildString 0
		getSym
		sub
	][ getmem -1 $symIsParam eq [[
		push 0
		+$call_local_ofs
		sub
		+$cur_fname call @funcDeclGet +(FuncDecl.locals)
		symTabSz dec
		sub
		+$cur_fname call @funcDeclGet +(FuncDecl.parameters)
		astGetChildString 0
		getSym
		sub
	][ getmem -1 $symIsGlobal eq [[
			+$glob_dic
			astGetChildString 0
		getSym
	][ getmem -1 $symIsClosure eq [[
		push "Error : closures not yet implemented (can't handle symbol '"
		getmem -1
		push "')\n"
		print 3
	][ getmem -1 $symMushEnclose eq [[
		push "Error : closures not yet implemented (can't handle symbol '"
		getmem -1
		push "')\n"
		print 3
	][ getmem -1 $symUnknown eq [
		push "Error : symbol is unknown (can't handle symbol '"
		getmem -1
		push "')\n"
		print 3
	] ]] ]] ]] ]] ]]
	leave 1
	ret 0

_skip_0:nop
end

language

 Script ::= "script" <script_loop>.
 script_loop = ( <script_statement> <script_loop> | "end" ).
 script_statement = ( <script_glob> | <script_glob_fun> | <script_instruction> ).

 script_glob ::= "global" <script_sym_loop>.
 script_loc ::= "local" <script_sym_loop>.
 script_sym_loop = ( <sym> "," <script_sym_loop> | <sym> ).
 script_id ::= <sym>.
 script_string ::= <string>.

 script_glob_fun ::= "function" <sym> <script_fun_decl>.
 script_anon_fun ::= "function" <script_fun_decl>.
 script_fun_decl ::= <script_param_list> <script_fun_body>.
 script_param_list ::= "(" ( <script_sym_loop> ")" | ")" ).
 script_fun_body ::= ( <script_local> <sfb_loop> | <sfb_loop> ).
 sfb_loop = ( <script_instruction> <sfb_loop> | "end" ).
 script_local ::= "local" <script_sym_loop>.

 script_instruction = ( <script_if> | <script_while> | <script_assign> | <script_call> | <AsmBloc> | <script_print> | <script_return> ).

 script_while ::= "while" <b_expr> "do" <sb_end>.
 script_if ::= "if" <b_expr> "then" ( <sb_else> <sb_end> | <sb_end> ).

 sb_end ::= <sbloop_end>.
 sb_else ::= <sbloop_else>.
 sbloop_end = ( <script_instruction> <sbloop_end> | "end" ).
 sbloop_else = ( <script_instruction> <sbloop_else> | "else" ).

 script_call ::= <script_var> "(" ( ")" | <script_expr_loop> ).
 script_expr_loop = <script_expr> ( "," <script_expr_loop> | ")" ).
 

 script_print ::= "print" <script_print_loop>.
 script_print_loop = ( <script_expr> "," <script_print_loop> | <script_expr> ).
 script_expr = ( <script_string> | <script_anon_fun> | <b_expr> | <m_expr> ).

 script_return ::= "return" <script_expr>.

 script_assign ::= <script_var> "=" ( <script_expr> ).

 script_int ::= <int>.
 script_float ::= <float>.
 number = ( <script_float> | <script_int> | <script_call> | <script_var> | "(" <m_expr> ")" ).

 script_var ::= ( <script_var> (<script_array_access>|<script_struc_access>) | ( <script_env> |<script_id> )).

 script_env ::= "&" <sym>.

 script_array_access ::= "[" <m_expr> "]".
 script_struc_access ::= "." <sym>.

 m_expr = <expr4>.
 b_expr = <bexpr4>.

atom = ( <script_float> | <script_int> | <script_call> | <script_var> | "(" <script_expr> ")" ).

m_minus ::= "-" <number>.
m_div ::= ( <m_div> "/" <expr0> | <expr0> "/" <expr0> ).
m_mul ::= ( <m_mul> "*" <expr1> | <expr1> "*" <expr1> ).
m_sub ::= ( <m_sub> "-" <expr2> | <expr2> "-" <expr2> ).
m_add ::= ( <m_add> "+" <expr3> | <expr3> "+" <expr3> ).

b_not ::= "not" <m_expr>.
b_and ::= ( <b_and> "and" <bexpr1> | <bexpr1> "and" <bexpr1> ).
b_or ::= ( <b_or> "or" <bexpr2> | <bexpr2> "or" <bexpr2> ).

comp ::= <bexpr2> /(<|>|=|!=|>=|<=)/ <bexpr2>.

expr0 = ( <m_minus> | <number> ).
expr1 = ( <m_div> | <expr0> ).
expr2 = ( <m_mul> | <expr1> ).
expr3 = ( <m_sub> | <expr2> ).
expr4 = ( <m_add> | <expr3> ).

bexpr1 = ( <b_not> | <m_expr> ).
bexpr2 = ( <b_and> | <bexpr1> ).
bexpr3 = ( <b_or> | <bexpr2> ).

bexpr4 = ( <comp> | <bexpr2> ).

end



plug Script into p_Code

compile Script asm
	#pp_curNode
	compileStateDown
end



compile script_glob
asm
	#pp_curNode
	# size,counter
	enter 2
	# if(!node_opd_count) return
	astGetChildrenCount
	SNZ jmp @done_glob
	# size = node_opd_count
	astGetChildrenCount setmem -1
	# write("data 0 rep $size end")
	getmem -1 push 0 write_data
	# counter=0
	push 0 setmem -2
	# do {
fill_glob_dict:
	# addsym(node_childString(counter,dic)
	+$glob_dic getmem -2 astGetChildString addSym
	# counter += 1
	getmem -2 inc setmem -2
	# } while(counter!=size)
	getmem -2 getmem -1 sub SZ jmp @fill_glob_dict
done_glob:
	leave 2
	compileStateNext
end


compile script_glob_fun
asm
	enter 1
	#pp_curNode
	+$glob_dic astGetChildString 0 getSym [
		push "Symbol " astGetChildString 0 push "\ already defined !\n" print 3
		compileStateError
		ret 0
	]

	astGetChildString 0 -$cur_fname

	push 1 push 0 write_data
	#+$glob_dic symTabSz setmem -1
	+$glob_dic
	#getmem -1
	+$cur_fname
	addSym
	+$glob_dic +$cur_fname getSym setmem -1

	# do "cur_fname = ...fun..."
	astCompileChild 1

#	push "Symbol '" +$cur_fname push "' has index " getmem -1 push "\\n" print 5

	getmem -1
	write_oc_Int "setmem"

	push "" -$cur_fname
	leave 1
	compileStateNext
end

compile script_anon_fun
asm
	push "anon" call @gen_label -$cur_fname
	astCompileChild 0
	push "" -$cur_fname
	compileStateNext
end


compile script_fun_decl
asm
	#pp_curNode
#	push "@@@   at start, $cur_fname = " +$cur_fname push "   @@@\\n" print 3
	enter 4
	+$cur_fname call @gen_label setmem -2
	push "endfun" call @gen_label setmem -3

	#push "start label \\\"" getmem -2 push "\\\"\\n" print 3
	#push "end label \\\"" getmem -3 push "\\\"\\n" print 3

	+$cur_fname
	call @newFuncDecl

	+$cur_fname
	call @funcDeclEnter

	getmem -3 write_oc_Label "jmp"
	getmem -2 write_label

	+$cur_fname call @funcDeclGet getmem -2 -(FuncDecl.label)

	+$cur_fname setmem -4

	doWalk "analyzeFuncDecl"

	getmem -4 -$cur_fname

	+$cur_fname
	call @funcDeclGet
	+(FuncDecl.locals)
	symTabSz dec setmem -1
	getmem -1 [
		getmem -1
		write_oc_Int "enter"
	]

	# skip parameters list, directly compile body
	astCompileChild 1

	getmem -4 -$cur_fname

	getmem -1 [
		getmem -1
		write_oc_Int "leave"
	]

	push 0 write_oc_Int "ret"
	getmem -3 write_label
	call @funcDeclLeave
	getmem -2 write_oc_Label "dynFunNew"

	push 0 setmem -1
#	push "\   @@@   NOW $cur_fname = " +$cur_fname push "   @@@\\n" print 3
	+$cur_fname call @funcDeclGet +(FuncDecl.closure_ofs) setmem -2
_addcls_loop:
	getmem -2 arraySize getmem -1 sup [
		getmem -2 getmem -1 arrayGet write_oc_Int "getmem"
		write_oc "dynFunAddClosure"
		getmem -1 inc setmem -1
		jmp @_addcls_loop
	]

	leave 4
	compileStateNext
end

compile script_fun_body asm compileStateDown end
compile script_local asm compileStateNext end

compile script_call
asm
	enter 3
	#astGetChildString 0
	astCompileChild 0
	#call @funcDeclGet
	#setmem -1
	push 1
	setmem -2
	#getmem -1
	#+(FuncDecl.parameters)
	#symTabSz dec setmem -3
	astGetChildrenCount dec setmem -3
	getmem -3 [ getmem -3 write_oc_Int "enter" ]
	getmem -3 +$call_local_ofs add -$call_local_ofs
_call_param_loop:
	getmem -2 astGetChildrenCount inf [
		getmem -2 astCompileChild
		push 0 getmem -2 sub write_oc_Int "setmem"
		getmem -2 inc setmem -2 jmp @_call_param_loop
	]
	#getmem -1 +(FuncDecl.label) write_oc_Label "call"
	write_oc "call"
	getmem -1
	getmem -3 [ getmem -3 write_oc_Int "leave" ]
	+$call_local_ofs getmem -3 sub -$call_local_ofs
	leave 3
	compileStateNext
end



compile script_loc asm compileStateNext end


compile script_id
asm
	enter 1
#	+$cur_fname
	astGetChildString 0
	call @getSymContext setmem -1
			getmem -1 $symIsLocal eq
			getmem -1 $symIsGlobal eq
		or
		getmem -1 $symIsParam eq
	or [[
		+$is_lvalue [[
			+$_sym_ofs
			write_oc_Int "setmem"
			push 0 -$is_lvalue
		][
			+$_sym_ofs
			write_oc_Int "getmem"
		]]
		leave 1
		compileStateNext
	][
		getmem -1 $symIsClosure eq [[
			+$is_lvalue [[
				+$_sym_ofs
				write_oc_Int "setClosure"
				push 0 -$is_lvalue
			][
				+$_sym_ofs
				write_oc_Int "getClosure"
			]]
			leave 1
			compileStateNext
		][
			push "At " astGetRow push ":" astGetCol push "\\t: " print 5
			push "Error with symbol context for sym '" astGetChildString 0 push "' : " print 3
			getmem -1 $symMustEnclose eq [ push "can't handle recursive closures yet\n" print 1]
			getmem -1 $symUnknown eq [ push "symbol is unknown.\n" print 1]
			leave 1
			compileStateError
		]]
	]]
end


compile script_print
asm
	# size,counter
	enter 2
	# if(!node_opd_count) return
	astGetChildrenCount
	SNZ jmp @done_print
	# size = node_opd_count
	astGetChildrenCount setmem -1
	# counter=0
	push 0 setmem -2
	# do {
fill_print:
	getmem -2 astCompileChild
	# counter += 1
	getmem -2 inc setmem -2
	# } while(counter!=size)
	getmem -2 getmem -1 sub SZ jmp @fill_print
done_print:
	astGetChildrenCount write_oc_Int "print"
	leave 2
	compileStateNext
end


compile script_assign
asm
	#pp_curNode
	enter 1
	#getmem 1 astGetChildString 0 getSym setmem -1
	# process righthand side
	astCompileChild 1
	# fetch memory location
	#getmem -1 write_oc_Int "setmem"
	push 1 -$is_lvalue
	astCompileChild 0
	leave 1
	compileStateNext
end


compile script_return
asm
	#pp_curNode
	# process righthand side
	astCompileChild 0
	push 0 write_oc_Int "ret"
	compileStateNext
end


compile script_string
asm
	astGetChildString 0
	write_oc_String "push"
	compileStateNext
end



compile script_param_list
asm
	push "script:"
	astGetOp
	push ": Not implemented.\n"
	print 3
	compileStateNext
end


compile script_int
asm
	astGetChildString 0 toI
	write_oc_Int "push"
	compileStateNext
end


compile script_float
asm
	astGetChildString 0 toF
	write_oc_Float "push"
	compileStateNext
end


#compile m_expr
#asm
#	#pp_curNode
#	astCompileChild 0
#	compileStateNext
#end


#compile b_expr
#asm
#	#pp_curNode
#	astCompileChild 0
#	compileStateNext
#end


compile m_minus
asm
	push 0 write_oc_Int "push"
	astCompileChild 0
	write_oc "sub"
	compileStateNext
end


compile m_add
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "add"
	compileStateNext
end


compile m_sub
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "sub"
	compileStateNext
end


compile m_mul
asm
	#pp_curNode
	astCompileChild 0
	#pp_curNode
	astCompileChild 1
	write_oc "mul"
	compileStateNext
end


compile m_div
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "div"
	compileStateNext
end





compile b_and
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "and"
	compileStateNext
end


compile b_or
asm
	astCompileChild 0
	astCompileChild 1
	write_oc "or"
	compileStateNext
end


compile b_not
asm
	astCompileChild 0
	write_oc "not"
	compileStateNext
end



compile comp
asm
	astCompileChild 0
	astCompileChild 2
	astGetChildString 1
	dup 0 push ">" strcmp [[
	dup 0 push "<" strcmp [[
	dup 0 push ">=" strcmp [[
	dup 0 push "<=" strcmp [[
	dup 0 push "=" strcmp [[
	dup 0 push "!=" strcmp [[
		push "Hey, unknown comp op '"
		astGetChildString 1
		push "' !\n"
		print 3
	][
		write_oc "nEq"
	]]
	][
		write_oc "eq"
	]]
	][
		write_oc "infEq"
	]]
	][
		write_oc "supEq"
	]]
	][
		write_oc "inf"
	]]
	][
		write_oc "sup"
	]]
	pop
	compileStateNext
end



compile script_if
asm
	astGetChildrenCount push 3 eq [[
		# if then else
		enter 4
		+$cur_fname strcat "_if" call @gen_label setmem -1
		+$cur_fname strcat "_then" call @gen_label setmem -2
		+$cur_fname strcat "_else" call @gen_label setmem -3
		+$cur_fname strcat "_endif" call @gen_label setmem -4

		getmem -1 write_label
		astCompileChild 0

		write_oc "SNZ"
		getmem -3
		write_oc_Label "jmp"

		getmem -2 write_label

		astCompileChild 1

		getmem -4 write_oc_Label "jmp"
		getmem -3 write_label

		astCompileChild 2

		getmem -4 write_label

		leave 4
	][
		# if then
		enter 3
		+$cur_fname strcat "_if" call @gen_label setmem -1
		+$cur_fname strcat "_then" call @gen_label setmem -2
		+$cur_fname strcat "_endif" call @gen_label setmem -3

		getmem -1 write_label
		astCompileChild 0

		write_oc "SNZ"
		getmem -3
		write_oc_Label "jmp"

		getmem -2 write_label

		astCompileChild 1

		getmem -3 write_label

		leave 3
	]]
	compileStateNext
end


compile script_while
asm

	# if then
	enter 2
	+$cur_fname strcat "_while" call @gen_label setmem -1
	+$cur_fname strcat "_endwhile" call @gen_label setmem -2

	getmem -1 write_label
	astCompileChild 0

	write_oc "SNZ"
	getmem -2
	write_oc_Label "jmp"

	astCompileChild 1

	getmem -1 write_oc_Label "jmp"

	getmem -2 write_label

	leave 2
	compileStateNext
end


compile sb_end asm compileStateDown end
compile sb_else asm compileStateDown end

compile script_var asm
	+$is_lvalue astGetChildrenCount push 2 eq and [[
		push 0 -$is_lvalue
		astCompileChild 0
		push 1 -$is_lvalue
		astCompileChild 1
		compileStateNext
		push 0 -$is_lvalue
	][
		compileStateDown
	]]
end


compile script_env asm
	+$is_lvalue [[
		astGetChildString 0
		write_oc_EnvSym "envSet"
		push 0 -$is_lvalue
	][
		astGetChildString 0
		write_oc_EnvSym "envGet"
	]]
	compileStateNext
end


compile script_array_access asm
	+$is_lvalue [[
		push -1 write_oc_Int "dup"
		astCompileChild 0
		write_oc "arraySet"
		push 2
		write_oc_Int "pop"
		push 0 -$is_lvalue
	][
		astCompileChild 0
		write_oc "arrayGet"
	]]
	compileStateNext
end

compile script_struc_access asm
	astGetChildString 0
	+$is_lvalue [[
		write_oc_String "mapSet"
		push 0 -$is_lvalue
	][
		write_oc_String "mapGet"
	]]
	compileStateNext
end

