require "symasm.melang" glob

################################################################################
# Tinyaml - script language
#
# Copyright (C) 2007 Damien Leroux
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.


# NOTE
# ----
#
# The calling convention is the following :
# Caller pushes args from right to left then pushes the number of args then calls.
# Callee cleans the stack then pushes its results then pushes the number of results then returns.
# i.e. Foo : A:a x B:b -> C:c x D:d
# Foo(a,b) gives
#	push a
#	push b
#	push 2
#	get Foo
#	call
# and return a,b in Foo() gives
#	push a
#	push b
#	push 2
#


#
# big tinyaml FIXME : define a nil/undef data value with type 0 (and possibly value 0, but may not be required)
#




	glob_dic = 0			# symbol table for globals
	func_dic = 0			# symbol table for functions
	func_tab = 0			# table of function decls
	local_dic_stack = 0		# stack for inner local contexts
# for scope management :
	symIsLocal = 101		# constants
	symIsParam = 102		#
	symIsGlobal = 103		#
	symIsClosure = 104		#
	symMustEnclose = 105		#
	symUnknown = 106		#

	call_size         = 0
	expr_size         = 0
	legal_return_size = 0		# number of values that must or may be returned.
					# 0 causes any return to be discarded.
					# 1 or more retain only as many values, and make the call fail if not enough values are returned.
					# -1 for the "running size" stub. i.e. handle  foo(x) => a,b  and  foo(x),c => a,b,c
					# full running size handling is :
					# local sz { push 0 -$sz (compile_expr...) (compile one call) +$sz add -$sz (...) +$sz add (computed constant : count of expressions in return (all children - all calls)) }
					# TODO : handle running size in call parameters lists also !

	expr_list_calls = 0		# temporary variable : count calls in a script_expr_list
	expr_list_exprs = 0		# temporary variable : count single expressions in a script_expr_list

	exprListRunningSize = 201
	exprListOnlyExprs = 202
	exprListOnlyCall = 203

	_sym_ofs = 0

	cur_fname = 0
	lbl_counter = 0

	call_local_ofs = 0
	is_lvalue = 0
	current_end_tc = 0		# global for try-catch bloc management
end


struc FuncDecl {
	returns		# int : maximum count of returned values
	parameters	# symtab : parameters
	locals		# symtab : local variables
	closure		# symtab : enclosed variables
	closure_ofs	# array : offsets of variables to clone in closure
	label		# string : start label
	has_vararg	# int : 0 if function doesn't use a variable argument
}


walker analyzeFuncDecl {

	init asm
		nop
	end

	terminate asm
		nop
	end

	default asm
#		push "analyzeFuncDecl default on " astGetOp push "\\n" print 3
		compileStateNext
	end

	on script_fun_decl asm
		# process param list
		walkChild 0

		+$cur_fname
		call @funcDeclEnter

		# process body
		walkChild 1

		call @funcDeclLeave

		compileStateDone
	end

	on script_glob_fun asm walkChild 1 compileStateNext end
	on script_anon_fun asm compileStateDown end

	on script_var asm compileStateDown end
	on script_array_access asm compileStateDown end
	on script_struc_access asm compileStateNext end
	on script_throw asm compileStateNext end
	on script_try asm compileStateNext end


	on script_param_list asm
		local counter {				# counter
			push 0 -$counter
#			pp_curNode
		_spl_loop:
			+$counter astGetChildrenCount nEq [
				#+$cur_fname
				#+$counter
				#astGetChildString
				#call @funcDeclAddParam
				+$counter walkChild
				+$counter inc -$counter
				jmp @_spl_loop
			]
		}
		compileStateDone
	end

	on script_param asm +$cur_fname astGetChildString 0 call @funcDeclAddParam compileStateNext end
	on script_vararg asm +$cur_fname astGetChildString 0 call @funcDeclAddVararg compileStateNext end


	on script_local asm
		local counter {				# counter
			push 0 -$counter
		_sl_loop:
			+$counter astGetChildrenCount nEq [
				#+$counter walkChild
				+$cur_fname
				+$counter astGetChildString
				call @funcDeclAddLocal
				+$counter inc -$counter
				jmp @_sl_loop
			]
		}
		compileStateNext
	end
	

	on script_id asm
		local sc {
			+$cur_fname
			astGetChildString 0
			call @getSymContext 
			-$sc
			+$sc $symIsLocal eq [
				nop
			]
			+$sc $symIsParam eq [
				nop
			]
			+$sc $symIsGlobal eq [
				nop
			]
			+$sc $symIsClosure eq [
				nop
			]
			+$sc $symMustEnclose eq [
				nop
	#			push "symbol must be enclosed\\n" print 1
			]
			+$sc $symUnknown eq [
				nop
	#			push "symbol is unknown\\n" print 1
			]
		}
		compileStateNext
	end


	on script_assign	asm compileStateDown end
	on script_fun_body	asm compileStateDown end
	on script_print		asm compileStateDown end
	on script_expr_list	asm compileStateDown end
	on script_var_list	asm compileStateDown end
	on instruction_seq	asm compileStateDown end
	on m_expr		asm compileStateDown end
	on b_expr		asm compileStateDown end
	on comp			asm compileStateDown end
	on m_add		asm compileStateDown end
	on m_sub		asm compileStateDown end
	on m_mul		asm compileStateDown end
	on m_div		asm compileStateDown end
	on b_not		asm compileStateDown end
	on b_and		asm compileStateDown end
	on b_or			asm compileStateDown end
	on script_call		asm compileStateDown end
	on script_if		asm compileStateDown end
	on sb_end		asm compileStateDown end
	on sb_else		asm compileStateDown end
}

asm
	jmp @_skip_0

reset_tables:
	newSymTab -$glob_dic
	newSymTab -$func_dic
	arrayNew  -$func_tab
	+$func_tab push 0 push 0 arraySet
	stackNew -$local_dic_stack
	ret 0

inc_exprs:
	+$expr_list_exprs inc -$expr_list_exprs
	ret 0

inc_calls:
	+$expr_list_calls inc -$expr_list_calls
	ret 0

# string:something -> string:label
gen_label:
	+$lbl_counter inc -$lbl_counter
	push "_" +$lbl_counter toS strcat strcat
	ret 0

newFuncDecl:
	local fname {
		# backup func name
		-$fname
		# insert symbol into tab
		+$func_dic
		+$fname
		addSym
		# add new func decl entry into tab
		+$func_tab
		# create structure
		strucNew FuncDecl {
			returns : push 0
			parameters : newSymTab
			locals : newSymTab
			closure : newSymTab
			closure_ofs : arrayNew
			label : push ""
			has_vararg : push 0
		}
		# fetch index of sym
		+$func_dic +$fname getSym
		arraySet
		pop
	}
	ret 0

funcDeclGet:
	local fname { -$fname
		+$func_tab
		+$func_dic +$fname getSym
		arrayGet
	}
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddParam:
	local pname { -$pname	# pop param name
		call @funcDeclGet +(FuncDecl.parameters)
		+$pname
		addSym
	}
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddVararg:
	local fname {
		dup -1 -$fname
		call @funcDeclAddParam
		+$fname call @funcDeclGet push 1 -(FuncDecl.has_vararg)
	}
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddLocal:
	local pname {
		# pop param name
		-$pname
		call @funcDeclGet +(FuncDecl.locals)
		+$pname
		addSym
	}
	ret 0

# string:func_name X string:param_name -> nil
funcDeclAddClosure:
	local pname {
		# pop param name
		-$pname
		call @funcDeclGet +(FuncDecl.closure)
		+$pname
		addSym
	}
	ret 0

# string:func_name -> nil
funcDeclAddReturn:
	call @funcDeclGet dup 0 +(FuncDecl.returns) inc -(FuncDecl.returns)
	ret 0

# string:func_name -> nil
funcDeclEnter:
	local fdecl {
		call @funcDeclGet -$fdecl
		+$local_dic_stack +$fdecl stackPush
	}
	ret 0

funcDeclLeave:
	+$local_dic_stack stackPop
	ret 0

# string:symbol -> int:context (cf. symIs...)
getSymContext:
	local symbol, locdic, symofs, counter, backup {
	-$symbol

	push 0 -$_sym_ofs

###	push "entering getSymContext... " +$local_dic_stack stackSize push "\\n" print 3

	+$local_dic_stack stackSize [

###		push "entering local context...\\n" print 1

		+$local_dic_stack stackPeek 0 -$locdic
		+$locdic -$backup

		+$locdic +(FuncDecl.locals) +$symbol getSym -$symofs
		+$symofs [
			push 0 +$symofs sub +$call_local_ofs sub -$_sym_ofs
###			push "Symbol '" +$symbol push "' is local at ofs " +$_sym_ofs push "\\n" print 5
			$symIsLocal jmp @_sc_ret ]

		+$locdic +(FuncDecl.parameters) +$symbol getSym -$symofs
		+$symofs [
			push 0 +$locdic +(FuncDecl.locals) symTabSz dec sub +$symofs sub +$call_local_ofs sub -$_sym_ofs
###			push "Symbol '" +$symbol push "' is a parameter at ofs " +$_sym_ofs push "\\n" print 5
			$symIsParam jmp @_sc_ret ]

		+$locdic +(FuncDecl.closure) +$symbol getSym -$symofs
		+$symofs [
			+$symofs dec -$_sym_ofs
###			push "Symbol '" +$symbol push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
			$symIsClosure jmp @_sc_ret ]

		push 0 -$counter

		push 0 +$call_local_ofs sub
#		+$locdic +(FuncDecl.locals) symTabSz dec
#		+$locdic +(FuncDecl.parameters) symTabSz dec
#		add sub
		-$_sym_ofs

		+$counter inc -$counter

	_context_loop:
		+$local_dic_stack stackSize +$counter sup [

###			push "entering local sub-context #" +$counter push "...\\n" print 3
###			push "base _sym_ofs is " +$_sym_ofs push "\\n" print 3

			+$local_dic_stack +$counter stackPeek -$locdic

			+$locdic +(FuncDecl.locals) +$symbol getSym -$symofs
			+$symofs [
				+$backup +(FuncDecl.closure) +$symbol addSym
				+$backup +(FuncDecl.closure_ofs)
					+$_sym_ofs
					+$symofs
					sub -$_sym_ofs
					+$_sym_ofs
					+$backup +(FuncDecl.closure_ofs) arraySize
				arraySet
#				push "Symbol local '" +$symbol push "' outbound ofs is " +$_sym_ofs push "\\n" print 5
				+$backup +(FuncDecl.closure) +$symbol getSym dec -$_sym_ofs
#				push "Symbol '" +$symbol push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
				$symIsClosure jmp @_sc_ret ]
	
			+$locdic +(FuncDecl.parameters) +$symbol getSym -$symofs
			+$symofs [
				+$backup +(FuncDecl.closure) +$symbol addSym
				+$backup +(FuncDecl.closure_ofs)
					+$_sym_ofs
					+$locdic +(FuncDecl.locals) symTabSz dec
					sub
					+$symofs dec
					sub -$_sym_ofs
					+$_sym_ofs
					+$backup +(FuncDecl.closure_ofs) arraySize
				arraySet
#				push "Symbol param '" +$symbol push "' outbound ofs is " +$_sym_ofs push "\\n" print 5
				+$backup +(FuncDecl.closure) +$symbol getSym dec -$_sym_ofs
#				push "Symbol '" +$symbol push "' is in closure at ofs " +$_sym_ofs push "\\n" print 5
				$symIsClosure jmp @_sc_ret ]
	
			+$locdic +(FuncDecl.closure) +$symbol getSym dec -$symofs
			+$symofs push -1 sup [
				push "Error : can't access symbol '" +$symbol push "' in outer closure, offset " +$symofs push ".\n" print 5
				$symMustEnclose jmp @_sc_ret ]

			+$_sym_ofs
			+$locdic +(FuncDecl.locals) symTabSz dec
			+$locdic +(FuncDecl.parameters) symTabSz dec
			add sub
			-$_sym_ofs

			+$counter inc -$counter
			jmp @_context_loop
		]
	]

	+$glob_dic +$symbol getSym -$symofs
	+$symofs [
		+$symofs -$_sym_ofs
###		push "Symbol '" +$symbol push "' is global at ofs " +$_sym_ofs push "\\n" print 5
		$symIsGlobal jmp @_sc_ret ]

	$symUnknown
_sc_ret:}
	ret 0

_skip_0:
end

language

 Script ::= "script" script_glob script_statement+ "end".
 script_statement = ( script_glob_fun | script_instruction ).

 script_glob ::= ("global" sym ("," sym)*|_epsilon).
 script_loc ::= "local"  sym ("," sym)*.
 script_id ::= sym.
 script_string ::= string.

 script_glob_fun ::= "function" sym script_fun_decl.
 script_anon_fun ::= "function" script_fun_decl.
 script_fun_decl ::= script_param_list script_fun_body.
 script_param_list ::= "(" ( ")" | (script_param ",")* ( script_vararg | script_param ) ")" ).
 script_param ::= sym.
 script_vararg ::= sym "...".
 script_fun_body ::= script_local? script_instruction+ "end".
 script_local ::= "local" sym ("," sym)*.

 script_instruction = ( script_if | script_while | AsmBloc | script_print | script_return | script_throw | script_try | script_assign | script_call ).
 instruction_seq = script_instruction+.
 instruction_bloc ::= instruction_seq.

 script_try ::= "try" instruction_bloc "catch" catch_bloc.
 catch_bloc ::= catch_bloc_loop.
 catch_bloc_loop = ( catch_statement catch_bloc_loop | "end" ).
 catch_statement ::= sym ":" instruction_bloc.
 script_throw ::= "throw" sym.

 script_while ::= "while" b_expr "do" sb_end.
 script_if ::= "if" b_expr "then" ( sb_else sb_end | sb_end ).

 sb_end ::= sbloop_end.
 sb_else ::= sbloop_else.
 sbloop_end = ( script_instruction sbloop_end | "end" ).
 sbloop_else = ( script_instruction sbloop_else | "else" ).

 script_call ::= script_var "(" ( ")" | script_expr_list ")" ).

 script_print ::= "print" script_print_loop.
 script_print_loop = ( script_expr "," script_print_loop | script_expr ).
 script_expr = (script_expr_atom | script_expr_tuple).
 
 script_expr_atom ::= ( script_string | script_anon_fun | b_expr | m_expr ).
 script_expr_tuple ::= script_call.

 script_return ::= "return" script_expr_list.
 script_expr_list ::= _epsilon (script_expr ",")* script_expr script_expr_list_end.
 script_expr_list_end ::= _epsilon.

 script_assign ::= script_var_list "=" script_expr_list.

 script_int ::= int.
 script_float ::= float.
 number = ( script_float | script_int | script_call_ret_1 | script_var | "(" m_expr ")" ).

 script_var ::= ( script_var (script_array_access|script_struc_access) | ( script_env | script_id )).
 script_var_list ::= _epsilon (script_var ",")* script_var.

 script_env ::= "&" sym.

 script_array_access ::= "[" m_expr "]".
 script_struc_access ::= "." sym.

 m_expr = expr4.
 b_expr = bexpr4.

atom = ( script_float | script_int | script_call_ret_1 | script_var | "(" script_expr ")" ).

script_call_ret_1 ::= script_call.

m_minus ::= "-" number.
m_div ::= ( m_div "/" expr0 | expr0 "/" expr0 ).
m_mul ::= ( m_mul "*" expr1 | expr1 "*" expr1 ).
m_sub ::= ( m_sub "-" expr2 | expr2 "-" expr2 ).
m_add ::= ( m_add "+" expr3 | expr3 "+" expr3 ).

b_not ::= "not" m_expr.
b_and ::= ( b_and "and" bexpr1 | bexpr1 "and" bexpr1 ).
b_or ::= ( b_or "or" bexpr2 | bexpr2 "or" bexpr2 ).

comp ::= bexpr2 /(<|>|=|!=|>=|<=)/ bexpr2.

expr0 = ( m_minus | number ).
expr1 = ( m_div | expr0 ).
expr2 = ( m_mul | expr1 ).
expr3 = ( m_sub | expr2 ).
expr4 = ( m_add | expr3 ).

bexpr1 = ( b_not | m_expr ).
bexpr2 = ( b_and | bexpr1 ).
bexpr3 = ( b_or | bexpr2 ).

bexpr4 = ( comp | bexpr2 ).

end


plug Script into p_Code



compile Script asm
	#pp_curNode
	compileStateDown
end

compile instruction_bloc asm compileStateDown end
compile instruction_expr_list asm compileStateDown end


compile script_throw asm
	<< push s(astGetChildString 0) throw >>
	compileStateNext
end


compile script_try asm
	local try_lbl, catch_lbl, end_lbl {
		push "try" call @gen_label -$try_lbl
		push "catch" call @gen_label -$catch_lbl
		push "end_trycatch" call @gen_label -$end_lbl

		# try: instCatcher @catch
		<< (+$try_lbl): instCatcher l(+$catch_lbl) >>
		# ...
		astCompileChild 0
		# jmp @end_trycatch catch:
		<< uninstCatcher l(+$end_lbl) (+$catch_lbl): >>
		# ...
		+$end_lbl -$current_end_tc
		astCompileChild 1
		# end_trycatch:
		<< (+$end_lbl): >>
	}
	compileStateNext
end


compile catch_statement asm
	local end_lbl {
		push "endcatch_" astGetChildString 0 strcat call @gen_label -$end_lbl
		<< getException strcmp s(astGetChildString 0) SZ jmp l(+$end_lbl) >>
		astCompileChild 1
		<< jmp l(+$current_end_tc) (+$end_lbl): >>
	}
	compileStateNext
end

compile catch_bloc asm
	local counter {
		push 0 -$counter
	catch_bloc_loop:
		+$counter astGetChildrenCount inf [
			+$counter astCompileChild
			+$counter inc -$counter
			jmp @catch_bloc_loop
		]

		# default: propagate exception
		<< getException throw >>
	}
	compileStateNext
end


compile script_glob
asm
	call @reset_tables
	#pp_curNode
	# size,counter
	local size, counter {
		# if(!node_opd_count) return
		astGetChildrenCount
		SNZ jmp @done_glob
		# size = node_opd_count
		astGetChildrenCount -$size
		# write("data 0 rep $size end")
		+$size push 0 write_data
		# counter=0
		push 0 -$counter
		# do {
	fill_glob_dict:
		# addsym(node_childString(counter,dic)
#		push "fill glob #" +$counter push "\\n" print 3
		+$glob_dic +$counter astGetChildString addSym
		# counter += 1
		+$counter inc -$counter
		# } while(counter<size)
		+$counter +$size inf SZ jmp @fill_glob_dict
	done_glob:
	}
	compileStateNext
end


compile script_glob_fun
asm
	local sz {
		#pp_curNode
		+$glob_dic astGetChildString 0 getSym [
			push "Symbol " astGetChildString 0 push "\ already defined !\n" print 3
			compileStateError
			ret 0
		]

		astGetChildString 0 -$cur_fname

		push 1 push 0 write_data
		#+$glob_dic symTabSz -$sz
		+$glob_dic
		#+$sz
		+$cur_fname
		addSym
		+$glob_dic +$cur_fname getSym -$sz

		# do "cur_fname = ...fun..."
		astCompileChild 1

	#	push "Symbol '" +$cur_fname push "' has index " +$sz push "\\n" print 5

		<< setmem i(+$sz) >>

		push "" -$cur_fname
	}
	compileStateNext
end

compile script_anon_fun
asm
	local clo_backup {
		+$call_local_ofs -$clo_backup
		push 0 -$call_local_ofs
		push "anon" call @gen_label -$cur_fname
		astCompileChild 0
		push "" -$cur_fname
		+$clo_backup -$call_local_ofs
	}
	compileStateNext
end


compile script_fun_decl
asm
	#pp_curNode
#	push "@@@   at start, $cur_fname = " +$cur_fname push "   @@@\\n" print 3
	local locsz, fun_lbl, endfun_lbl, fname_backup, supargc, argc, top, count {
		+$cur_fname call @gen_label -$fun_lbl
		push "endfun" call @gen_label -$endfun_lbl

		#push "start label \\\"" +$fun_lbl push "\\\"\\n" print 3
		#push "end label \\\"" -$enfdun_lbl push "\\\"\\n" print 3

		+$cur_fname
		call @newFuncDecl

		+$cur_fname
		call @funcDeclEnter

		<< jmp l(+$endfun_lbl) (+$fun_lbl): >>

		+$cur_fname call @funcDeclGet +$fun_lbl -(FuncDecl.label)

		+$cur_fname -$fname_backup

		doWalk "analyzeFuncDecl"

		+$fname_backup -$cur_fname

		# insert function header
		#	- if no vararg : check against dynamic argc, throw badarg if nEq
		#	- if vararg : compute supplementary argc, copy sup' args into an array, install the array as last arg
		# first, code to fetch dynamic argc
		+$cur_fname call @funcDeclGet +(FuncDecl.has_vararg) [[
			nop
	#		-$argc
	#		+$argc
	#		# compute supargc
	#		+$cur_fname call @funcDeclGet +(FuncDecl.parameters) sub 2 -$supargc
	#		# check that supargc>=0
	#		<<supEq i(+$supargc) >>
	#
	#		# prepare array counter max
	#		+$argc
	#		+$supargc
	#		sub
	#
	#		# throw if failed
	#		push "check_argc_pass" call @gen_label -$supargc
	#		<< SZ >>
	#		+$supargc write_ocLabel "jmp"
	#		push "WrongParameterCount" << throw >>
	#		+$supargc write_label
	#
	#	+$cur_fname push "_vastart_loop" strcat -$endfun_lbl
	#	# start count
	#<<
	#	enter 2
	#	arrayNew
	#	arrayResv (+$argc)
	#	-$fun_lbl
	#	push 0 -$locsz
	#	# get -1-count -th arg
	#(:	+$fun_lbl 
	#	push -1 +$locsz sub getmem
	#	+$locsz
	#	arraySet
	#	+$locsz inc -$locsz
	#	+$locsz inf (+$argc) SZ jmp @_loop
	#>>	
	#
	#
	#
	#		# store array counter max
	#		-$supargc
	#		# now copy
	#		push 1 write_ocInt "enter"
	#		push 0 write_ocInt "push"
	#		push -1 write_
	#		push 1 write_ocInt "leave"
			

		][
			push "check_argc_pass" call @gen_label -$supargc
			# throw if failed
			<< dup 0
			   push i( +$cur_fname call @funcDeclGet +(FuncDecl.parameters) symTabSz dec)
			   eq
			   SZ
			   jmp l(+$supargc)
			   push "WrongParameterCount ("
			   push i( +$cur_fname call @funcDeclGet +(FuncDecl.parameters) symTabSz dec) toS
			   strcat
			   push " expected, "
			   strcat
			   dup -1 toS
			   strcat
			   push " given)"
			   strcat
			   throw
			   (+$supargc):
			   pop
			>>
			+$cur_fname call @funcDeclGet +(FuncDecl.parameters) symTabSz dec
			+$cur_fname call @funcDeclGet +(FuncDecl.locals) symTabSz dec
			add
			-$locsz
			+$locsz [ << enter i(+$locsz) >> ]
			+$cur_fname call @funcDeclGet +(FuncDecl.parameters) symTabSz dec
			dup 0 [[
				push 0 +$cur_fname call @funcDeclGet +(FuncDecl.locals) symTabSz dec sub -$top
				+$top dup -1 sub -$count
			_prep_parm_loop:
				push "sur le param " +$count push " sur " +$top push "\\n" print 5
				<< setmem i(+$count) >>
				+$count inc -$count
				#push "suivant " +$count push " < 0 ?\\n" print 3
				+$count +$top inf SZ jmp @_prep_parm_loop
			_prep_parm_done:
			][
				pop
			]]
		]]


		#+$cur_fname
		#call @funcDeclGet
		#+(FuncDecl.locals)
		#symTabSz dec -$locsz
		#+$locsz [ << enter i(+$locsz) >> ]

		# skip parameters list, directly compile body
		astCompileChild 1

		+$fname_backup -$cur_fname

		+$locsz [ << leave i(+$locsz) >> ]

		# if no return statement has been issued, default to void return (size 0)
		<< push 0 ret 0 (+$endfun_lbl): dynFunNew l(+$fun_lbl) >>
		call @funcDeclLeave

		push 0 -$locsz
	#	push "\   @@@   NOW $cur_fname = " +$cur_fname push "   @@@\\n" print 3
		+$cur_fname call @funcDeclGet +(FuncDecl.closure_ofs) -$fun_lbl
	_addcls_loop:
		+$fun_lbl arraySize +$locsz sup [
			<< getmem i(+$fun_lbl +$locsz arrayGet) dynFunAddClosure >>
			+$locsz inc -$locsz
			jmp @_addcls_loop
		]

	}
	compileStateNext
end

compile script_fun_body asm compileStateDown end
compile script_local asm compileStateNext end


walker exprListType {
	init asm push 0 -$expr_list_calls push 0 -$expr_list_exprs end
	terminate asm nop end
	default asm push "exprListType::default on " astGetOp push "\n" print 3 compileStateError end

	# entry point
	on script_expr_list asm pp_curNode compileStateDown end
	on script_expr_atom asm compileStateDown end
	on script_expr_tuple asm compileStateDown end
	on script_expr_end asm compileStateNext end

	# expr is a call
	on script_call asm +$expr_list_calls inc -$expr_list_calls compileStateNext end

	# expr is an atom
	on script_anon_fun asm call @inc_exprs compileStateNext end

	on script_int asm call @inc_exprs compileStateNext end
	on script_float asm call @inc_exprs compileStateNext end
	on script_string asm call @inc_exprs compileStateNext end

	# expr is arithmetic or boolean operation
	on m_minus asm call @inc_exprs compileStateNext end
	on m_div asm call @inc_exprs compileStateNext end
	on m_mul asm call @inc_exprs compileStateNext end
	on m_add asm call @inc_exprs compileStateNext end
	on m_sub asm call @inc_exprs compileStateNext end

	on b_not asm call @inc_exprs compileStateNext end
	on b_and asm call @inc_exprs compileStateNext end
	on b_or  asm call @inc_exprs compileStateNext end
	on comp  asm call @inc_exprs compileStateNext end
}


compile script_expr_list
asm
	# different cases for handling expr size :
	# count number of litteral expressions Nle and count calls Nc
	# one single function call => no supplementary code at all 							Nc==1&&Nle==0
	# at least one call and any other element => use running size code and add number of exprs at end if non-zero
	# only exprs : push number of exprs at end
	doWalk "exprListType"

	local list_algo {
		+$expr_list_exprs [[
			+$expr_list_calls push 0 sup [[
				# si Nc > 0, running size
				$exprListRunningSize -$list_algo
				push "selecting list algo : Running size\n" print 1
			][
				# sinon, push Nle
				$exprListOnlyExprs -$list_algo
				push "selecting list algo : Only exprs\n" print 1
			]]
		][
			+$expr_list_calls push 1 eq [[
				# si Nc == 1, do nothing
				$exprListOnlyCall -$list_algo
				push "selecting list algo : Only one call\n" print 1
			][
				# sinon, running size
				$exprListRunningSize -$list_algo
				push "selecting list algo : Running size\n" print 1
				<< enter 1 push 0 setmem -1 >>
			]]
		]]
	}
	push 0 -$expr_size
	compileStateDown
end

compile script_expr_list_end
asm
	+$list_algo $exprListRunningSize [
		<< getmem -1 add i(+$expr_size) leave 1 >>
	]
	compileStateNext
end

compile script_expr_atom
asm
	astCompileChild 0
	+$expr_size inc -$expr_size
	compileStateNext
end

compile script_expr_tuple
asm
	# it is a call inside
	astCompileChild 0
	+$list_algo $exprListRunningSize [
		<< getmem -1 add setmem -1 >>
	]
	compileStateNext
end

compile script_var_list
asm
	astGetChildrenCount -$legal_expr_size
	compileStateDown
end


compile script_return
asm
	#pp_curNode
	# process righthand side
	astCompileChild 0
	<< ret 0 >>
	compileStateNext
end

compile script_call_ret_1
asm
	enter 1	+$legal_return_size setmem -1
	push 1
	+$legal_return_size
	astCompileChild 0
	getmem -1 -$legal_return_size
	leave 1
	compileStateNext
end

compile script_call
asm
	local counter, max, clo_backup, ret_fail, ret_good {

		push 1
		-$counter
		astGetChildrenCount dec -$max
		pp_curNode
		push "before loop : max = " +$max push "\\n" print 3
		push "before loop : call_local_ofs = " +$call_local_ofs push "\\n" print 3

	_call_param_loop:
		+$counter astGetChildrenCount inf [
			+$counter astCompileChild
			+$counter inc -$counter jmp @_call_param_loop
		]
		### push argc for use in function header
		##<< push i(astGetChildrenCount dec) >>
		# (push function object)
		astCompileChild 0
		# call
		<< call >>

		+$legal_return_size [[
			+$legal_return_size push 0 sup [[
				push "ret_fail" call @gen_label -$ret_fail
				push "ret_good" call @gen_label -$ret_good
				# discard some results if there are more
				# FIXME : clean up, remove {inf,eq,sub}.Int, remove botched code, rewrite everything in here.
				<<
					dup 0 inf i(+$legal_return_size) SZ jmp l(+$ret_fail)
					dup 0 eq i(+$legal_return_size) SNZ jmp l(+$ret_good)
					dup 0 sub i(+$legal_return_size) popN
					jmp l(+$ret_good)
				(+$ret_fail):
					pop
					push "InvalidReturnSize" throw
				(+$ret_good):
					pop
				>>
			][
				# compute running size, counter is in mem -1
				<< getmem -1 add setmem -1 >>
			]]
			
		][
			<< popN >>
		]]

		push "after loop : max = " +$max push "\\n" print 3
		push "after loop : call_local_ofs = " +$call_local_ofs push "\\n" print 3

#		astCompileChild 0
#		push 1
#		-$counter
#		astGetChildrenCount dec -$max
#		+$max [ << enter i(+$max) >> ]
#		+$call_local_ofs -$clo_backup	# push for later
#		+$max +$call_local_ofs add -$call_local_ofs
##		push "before loop : max = " +$max push "\\n" print 3
##		push "before loop : call_local_ofs = " +$call_local_ofs push "\\n" print 3
#
#		# push argc for use in function header
#		<< push i(astGetChildrenCount dec) >>
#
#	_call_param_loop:
#		+$counter astGetChildrenCount inf [
#			+$counter astCompileChild
#			<< setmem i(push 0 +$counter sub) >>
#			+$counter inc -$counter jmp @_call_param_loop
#		]
#		<< call >>
##		push "after loop : max = " +$max push "\\n" print 3
##		push "after loop : call_local_ofs = " +$call_local_ofs push "\\n" print 3
#		+$max [ << leave i(+$max) >> ]
#		#+$call_local_ofs +$max sub -$call_local_ofs
#		+$clo_backup -$call_local_ofs	# pop backup'd offset
	}
	compileStateNext
end



compile script_loc asm compileStateNext end


compile script_id
asm
	local symctxt {
	#	+$cur_fname
		astGetChildString 0
		call @getSymContext -$symctxt
				+$symctxt $symIsLocal eq
				+$symctxt $symIsGlobal eq
			or
			+$symctxt $symIsParam eq
		or [[
			+$is_lvalue [[
				<< setmem i(+$_sym_ofs) >>
				push 0 -$is_lvalue
			][
				<< getmem i(+$_sym_ofs) >>
			]]
			compileStateNext
		][
			+$symctxt $symIsClosure eq [[
				+$is_lvalue [[
					<< setClosure i(+$_sym_ofs) >>
					push 0 -$is_lvalue
				][
					<< getClosure i(+$_sym_ofs) >>
				]]
				compileStateNext
			][
				push "At " astGetRow push ":" astGetCol push "\\t: " print 5
				push "Error with symbol context for sym '" astGetChildString 0 push "' : " print 3
				+$symctxt $symMustEnclose eq [ push "can't handle recursive closures yet\n" print 1]
				+$symctxt $symUnknown eq [ push "symbol is unknown.\n" print 1]
				compileStateError
			]]
		]]
	}
end


compile script_print
asm
	# size,counter
	local size, counter {
		# if(!node_opd_count) return
		astGetChildrenCount
		SNZ jmp @done_print
		# size = node_opd_count
		astGetChildrenCount -$size
		# counter=0
		push 0 -$counter
		# do {
	fill_print:
		+$counter astCompileChild
		# counter += 1
		+$counter inc -$counter
		# } while(counter!=size)
		+$counter +$size inf SZ jmp @fill_print
	done_print:
		<< print i(astGetChildrenCount) >>
	}
	compileStateNext
end





compile script_assign
asm
	#pp_curNode
	local sym {
		#getmem 1 astGetChildString 0 getSym -$sym
		# process righthand side
		astCompileChild 1
		# process lefthand side
		push 1 -$is_lvalue
		astCompileChild 0
	}
	compileStateNext
end


compile script_string
asm
	<< push s(astGetChildString 0) >>
	compileStateNext
end



compile script_param_list
asm
	push "script:"
	astGetOp
	push ": Not implemented.\n"
	print 3
	compileStateNext
end


compile script_int
asm
	<< push i(astGetChildString 0 toI) >>
	compileStateNext
end


compile script_float
asm
	<< push f(astGetChildString 0 toF) >>
	compileStateNext
end


#compile m_expr
#asm
#	#pp_curNode
#	astCompileChild 0
#	compileStateNext
#end


#compile b_expr
#asm
#	#pp_curNode
#	astCompileChild 0
#	compileStateNext
#end


compile m_minus
asm
	<< push 0 >>
	astCompileChild 0
	<< sub >>
	compileStateNext
end


compile m_add
asm
	astCompileChild 0
	astCompileChild 1
	<< add >>
	compileStateNext
end


compile m_sub
asm
	astCompileChild 0
	astCompileChild 1
	<< sub >>
	compileStateNext
end


compile m_mul
asm
	#pp_curNode
	astCompileChild 0
	#pp_curNode
	astCompileChild 1
	<< mul >>
	compileStateNext
end


compile m_div
asm
	astCompileChild 0
	astCompileChild 1
	<< div >>
	compileStateNext
end





compile b_and
asm
	astCompileChild 0
	astCompileChild 1
	<< and >>
	compileStateNext
end


compile b_or
asm
	astCompileChild 0
	astCompileChild 1
	<< or >>
	compileStateNext
end


compile b_not
asm
	astCompileChild 0
	<< not >>
	compileStateNext
end



compile comp
asm
	astCompileChild 0
	astCompileChild 2
	astGetChildString 1
	dup 0 push ">" strcmp [[
	dup 0 push "<" strcmp [[
	dup 0 push ">=" strcmp [[
	dup 0 push "<=" strcmp [[
	dup 0 push "=" strcmp [[
	dup 0 push "!=" strcmp [[
		push "Hey, unknown comp op '"
		astGetChildString 1
		push "' !\n"
		print 3
	][
		<< nEq >>
	]]
	][
		<< eq >>
	]]
	][
		<< infEq >>
	]]
	][
		<< supEq >>
	]]
	][
		<< inf >>
	]]
	][
		<< sup >>
	]]
	pop
	compileStateNext
end



compile script_if
asm
	astGetChildrenCount push 3 eq [[
		# if then else
		local if_lbl, then_lbl, else_lbl, endif_lbl {
			+$cur_fname strcat "_if" call @gen_label -$if_lbl
			+$cur_fname strcat "_then" call @gen_label -$then_lbl
			+$cur_fname strcat "_else" call @gen_label -$else_lbl
			+$cur_fname strcat "_endif" call @gen_label -$endif_lbl

			<< (+$if_lbl): >>
			astCompileChild 0
			<< SNZ jmp l(+$else_lbl) (+$then_lbl): >>
			astCompileChild 1
			<< jmp l(+$endif_lbl) (+$else_lbl): >>
			astCompileChild 2
			<< (+$endif_lbl): >>
		}
	][
		# if then
		local if_lbl, then_lbl, endif_lbl {
			+$cur_fname strcat "_if" call @gen_label -$if_lbl
			+$cur_fname strcat "_then" call @gen_label -$then_lbl
			+$cur_fname strcat "_endif" call @gen_label -$endif_lbl

			<< (+$if_lbl): >>
			astCompileChild 0
			<< SNZ jmp l(+$endif_lbl) (+$then_lbl): >>
			astCompileChild 1
			<< (+$endif_lbl): >>
		}
	]]
	compileStateNext
end


compile script_while
asm

	local while_lbl, endwhile_lbl {
		+$cur_fname strcat "_while" call @gen_label -$while_lbl
		+$cur_fname strcat "_endwhile" call @gen_label -$endwhile_lbl

		<< (+$while_lbl): >>
		astCompileChild 0
		<< SNZ jmp l(+$endwhile_lbl) >>
		astCompileChild 1
		<< jmp l(+$while_lbl) (+$endwhile_lbl): >>
	}
	compileStateNext
end


compile sb_end asm compileStateDown end
compile sb_else asm compileStateDown end

compile script_var asm
	+$is_lvalue astGetChildrenCount push 2 eq and [[
		push 0 -$is_lvalue
		astCompileChild 0
		push 1 -$is_lvalue
		astCompileChild 1
		compileStateNext
		push 0 -$is_lvalue
	][
		compileStateDown
	]]
end


compile script_env asm
	+$is_lvalue [[
		<< envSet e(astGetChildString 0) >>
		push 0 -$is_lvalue
	][
		<< envGet e(astGetChildString 0) >>
	]]
	compileStateNext
end


compile script_array_access asm
	+$is_lvalue [[
		push 0 -$is_lvalue
		<< dup -1 >>
		astCompileChild 0
		<< arraySet >>
		push 2
		<< pop >>
	][
		astCompileChild 0
		<< arrayGet >>
	]]
	compileStateNext
end

compile script_struc_access asm
	+$is_lvalue [[
		<< mapSet s(astGetChildString 0) >>
		push 0 -$is_lvalue
	][
		<< mapGet s(astGetChildString 0) >>
	]]
	compileStateNext
end

