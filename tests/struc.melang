# Symbolic layer for the assembly language.
# Author : Damien "bl0b" Leroux
#
# handles a global symbol table for program's data segment
# and symbolic access to structured types.
#
# TODO : handle local frames also
#

data
	0	# 0 : symtab of struct names
	0	# 1 : array of struct fields tables
	0	# 2 : symtab to map the data segment
	0	# 3 : int counter for unique labels
end

asm
	newSymTab setmem 0
	arrayNew setmem 1
	call @globSymTabNew
	jmp @_skip_0

#
# calling convention : args and return are pushed onto data stack. callee must free stack.
#

globSymTabNew:
	newSymTab setmem 2
	ret 0

getGlobSym:
	# string:symbol on top of stack
		getmem 2
		dup -1
	getSym
	#push "getGlobSym " dup -1 push "\n" print 3
	retval 1

addGlobSym:
	enter 1
		setmem -1
		#push "addGlobSym " getmem -1 push "\n" print 3
		getmem 2
		getmem -1
	addSym
	leave 1
	ret 0

getStruc:
	# string:struc_name on top of stack
		getmem 2
			getmem 0
			dup -2
		getSym
	arrayGet
	retval 1

# string:something -> string:label
gen_label:
	getmem 3 inc setmem 3
	push "_" getmem 3 toS strcat strcat
	ret 0

_skip_0:
	nop
end

language
	GlobSymTab ::= "glob" <gs_loop>.
	gs_loop = ( <GlobSym> <gs_loop> | "end" ).
	GlobSym ::= <sym> "=" ( <gs_Int> | <gs_Float> | <gs_String> ).

	gs_Int ::= <int>.
	gs_Float ::= <float>.
	gs_String ::= <string>.

	GlobGet ::= "+" "$" <sym>.
	GlobSet ::= "-" "$" <sym>.
	GlobIdx ::= "$" <sym>.

	Struc ::= "struc" <sym> "{" <struc_loop>.
	StrucNew ::= "strucNew" <sym> "{" <newstruc_loop>.
	StrucGet ::= "+" "(" <sym> "." <sym> ")".
	StrucSet ::= "-" "(" <sym> "." <sym> ")".
	struc_loop = ( <sym> <struc_loop> | "}" ).
	newstruc_loop = ( <struc_item> <newstruc_loop> | "}" ).
	struc_item = <sym> ":" ( <AsmBloc> | <p_Opcode> ).

	SubAsmBloc::=epsilon.
	IfElseNZ ::= "[[" [<sab_co>]<SubAsmBloc> [<sab_cc>]<SubAsmBloc>.
	IfNZ ::= "[" [<sab_c>]<SubAsmBloc>.

	sab_c = ( "]" | <asm_statement> <sab_c> ).
	sab_cc = ( "]]" | <asm_statement> <sab_cc> ).
	sab_co = ( "][" | <asm_statement> <sab_co> ).

end

plug IfNZ into p_Opcode
plug IfElseNZ into p_Opcode
plug GlobSymTab into p_Data
plug Struc into p_ProgramTopLevel
plug GlobGet into p_Opcode
plug GlobSet into p_Opcode
plug GlobIdx into p_Opcode
plug StrucNew into p_Opcode
plug StrucGet into p_Opcode
plug StrucSet into p_Opcode

compile SubAsmBloc asm
	enter 1
		push 0 setmem -1
sab_loop:
		getmem -1 astGetChildrenCount sub SNZ jmp @sab_done

		getmem -1 astCompileChild

		getmem -1 inc setmem -1
		jmp @sab_loop
sab_done:
	leave 1
	compileStateNext
end

compile IfNZ asm
	enter 1
	push "endif" call @gen_label setmem -1
# SNZ jmp _end
# ...
# _end:
#
	write_oc "SNZ"
	getmem -1
	write_oc_Label "jmp"
	astCompileChild 0
	getmem -1
	write_label
	leave 1
	compileStateNext
end

compile IfElseNZ asm
	enter 2
	push "else" call @gen_label setmem -1
	push "endif" call @gen_label setmem -2
# SNZ jmp _else
# ...
# jmp _end
# _else:
#...
# _end:
#
	write_oc "SNZ"
	getmem -1
	write_oc_Label "jmp"
	astCompileChild 0
	getmem -2
	write_oc_Label "jmp"
	getmem -1
	write_label
	astCompileChild 1
	getmem -2
	write_label
	leave 2
	compileStateNext
end



compile gs_Int asm
	push 1			# rep
	astGetChildString 0 toI	# init value
	write_data		#
	compileStateDone
end

compile gs_Float asm
	push 1			# rep
	astGetChildString 0 toF	# init value
	write_data		#
	compileStateDone
end

compile gs_String asm
	push 1			# rep
	astGetChildString 0	# init value
	write_data		#
	compileStateDone
end

compile GlobSym asm
	astGetChildString 0
	call @addGlobSym
	astCompileChild 1
	compileStateDone
end

compile GlobSymTab asm
	call @globSymTabNew
	push 1 push 0 write_data	# reserve one empty data at offset #0
	enter 2
		astGetChildrenCount
	setmem -2
		push 0
	setmem -1
_fill_glob_loop:
			getmem -1
			getmem -2
		inf
	SNZ jmp @_done_glob_loop

		getmem -1
	astCompileChild

	getmem -1 inc setmem -1
	jmp @_fill_glob_loop
_done_glob_loop:
	leave 2
	compileStateNext
end




compile Struc asm
	enter 2
			newSymTab
		setmem -1
			push 1
		setmem -2
_fill_struc_loop:
				getmem -2
				astGetChildrenCount
			sub
		SNZ jmp @_done_struc_loop

			getmem -1
				getmem -2
			astGetChildString
		addSym

		getmem -2 inc setmem -2
		jmp @_fill_struc_loop
_done_struc_loop:
			getmem 0
			astGetChildString 0
		addSym
			getmem 1
			getmem -1
				getmem 0
				astGetChildString 0
			getSym
		arraySet
		pop
	leave 2
	compileStateNext
end


compile StrucNew asm
	enter 2
			getmem 1
				getmem 0
				astGetChildString 0
			getSym
		arrayGet
		setmem -2

		write_oc "arrayNew"

		#	push "children count : "
		#	astGetChildrenCount
		#	push "\n"
		#print 3

			astGetChildrenCount dec shr 1
		write_oc_Int "arrayResv"

			push 1
		setmem -1

_fill_newstruc_loop:
				getmem -1
				astGetChildrenCount
			sub
		SNZ jmp @_done_newstruc_loop

		#	push "compiling #"
		#	getmem -1 shr 1 inc
		#	push "\n"
		#print 3
			getmem -1 inc
		astCompileChild
			getmem -2
				getmem -1
			astGetChildString
		getSym dec
		write_oc_Int "arraySet"

		getmem -1 add 2 setmem -1
		jmp @_fill_newstruc_loop
_done_newstruc_loop:
	leave 2
	compileStateNext
end

compile StrucGet asm
			getmem 1
				getmem 0
				astGetChildString 0
			getSym
		arrayGet
		astGetChildString 1
	getSym dec
	write_oc_Int "arrayGet"
	compileStateNext
end

compile StrucSet asm
			getmem 1
				getmem 0
				astGetChildString 0
			getSym
		arrayGet
		astGetChildString 1
	getSym dec
	write_oc_Int "arraySet"
	compileStateNext
end



compile GlobGet asm
			astGetChildString 0
		call @getGlobSym
	write_oc_Int "getmem"
	compileStateNext
end


compile GlobSet asm
			astGetChildString 0
		call @getGlobSym
	write_oc_Int "setmem"
	compileStateNext
end

compile GlobIdx asm
			astGetChildString 0
		call @getGlobSym
	write_oc_Int "push"
	compileStateNext
end

